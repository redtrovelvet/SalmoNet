#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model="gpt-4" date=2025-03-08>
#and followed by #<END GENERATED></END>.

from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from social_distribution.models import Author, Post
import uuid
from django.contrib.auth.models import User

class SharingTests(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.owner_user = User.objects.create_user(username = "owner", password = "ownerpassword")
        self.author = Author.objects.create(
            id=uuid.uuid4(),
            username="owner",
            display_name="Owner Author",
            github="https://github.com/owner",
            host="http://127.0.0.1:8000",
            user=self.owner_user
        )

        self.public_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Public Post for Sharing",
            visibility="PUBLIC",
            content_type="text/plain"
        )
        
        self.unlisted_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Unlisted Post for Sharing",
            visibility="UNLISTED",
            content_type="text/plain"
        )

        self.friends_only_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Friends-only Post for Sharing",
            visibility="FRIENDS",
            content_type="text/plain"
        )

    def test_link_public_post(self):
        """
        Testing user story: As a reader, I can get a link to a public or unlisted post 
        so I can send it to my friends over email, discord, slack, etc. 
        Testing for public post.
        """
        url = reverse("posts_detail", args=[self.author.id, self.public_post.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected_url = f"http://127.0.0.1:8000/api/authors/{self.author.id}/posts/{self.public_post.id}"
        self.assertEqual(response.data.get("id"), expected_url)  # type:ignore

    def test_link_unlisted_post(self):
        """
        Testing user story: As a reader, I can get a link to a public or unlisted post 
        so I can send it to my friends over email, discord, slack, etc. 
        Testing for unlisted post.
        """
        url = reverse("posts_detail", args=[self.author.id, self.unlisted_post.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        expected_url = f"http://127.0.0.1:8000/api/authors/{self.author.id}/posts/{self.unlisted_post.id}"
        self.assertEqual(response.data.get("id"), expected_url)  # type:ignore
    
    def test_friends_only_post_unshareable(self):
        """
        Testing user story: As an author, I want my friends-only images and posts to not be shareable, 
        so I know that if someone wants to share it they'll at least have to take a screenshot.
        Note: public posts (including public image posts) are re-shareable.
        """
        not_owner = User.objects.create_user(username="notowner", password="notownerpassword")
        not_owner_author = Author.objects.create(
            id=uuid.uuid4(),
            username="notowner",
            display_name="Notowner Author",
            github="https://github.com/notowner",
            host="http://127.0.0.1:8000",
            user=not_owner
        )

        url = reverse("posts_detail", args=[self.author.id, self.friends_only_post.id])
        self.client.login(username="notowner", password="notownerpassword")
        response = self.client.get(url)
        self.assertEqual(response.status_code, 403)

    def test_browse_public_post(self):
        """
        Testing user story: As an author, I should be able to browse the public posts of everyone, 
        so that I can see what's going on beyond authors I follow.
        Note: this should include all local public posts and all public posts received in any inbox.
        """
        another_public_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Another Public Post",
            visibility="PUBLIC",
            content_type="text/plain"
        )
        url = reverse("author_posts", args=[self.author.id])

        self.client.logout()
        response_unauth = self.client.get(url)
        self.assertEqual(response_unauth.status_code, status.HTTP_200_OK)
        #<BEGIN GENERATED model="gpt-4" date=2025-03-08 prompt: how can i test that the user can browse all public posts when testing though api becuase if is returned in json format?>
        texts_unauth = [post["content"] for post in response_unauth.data["src"]] # type:ignore
        self.assertIn("Public Post for Sharing", texts_unauth)
        self.assertIn("Another Public Post", texts_unauth)
        #<END GENERATED></END>.

        self.client.login(username="owner", password="ownerpass")
        response_auth = self.client.get(url)
        self.assertEqual(response_auth.status_code, status.HTTP_200_OK)
        #<BEGIN GENERATED model="gpt-4" date=2025-03-08 prompt: how can i test that the user can browse all public posts when testing though api becuase if is returned in json format?>
        texts_auth = [post["content"] for post in response_auth.data["src"]] #type:ignore
        self.assertIn("Public Post for Sharing", texts_auth)
        self.assertIn("Another Public Post", texts_auth)
        #<END GENERATED></END>.
        
