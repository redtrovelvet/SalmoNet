#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model="gpt-4" date=2025-03-08>
#and followed by #<END GENERATED></END>.

from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from social_distribution.models import Author, Post
import uuid
from django.contrib.auth.models import User

class VisibilityTests(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.owner = User.objects.create_user(username="owner", password="ownerpass")
        self.author = Author.objects.create(
            id=uuid.uuid4(),
            username="owner",
            display_name="Owner Author",
            github="https://github.com/owner",
            host="http://127.0.0.1:8000",
            user=self.owner
        )
        self.friend = User.objects.create_user(username="friend", password="friendpass")
        self.friend_author = Author.objects.create(
            id=uuid.uuid4(),
            username="friend",
            display_name="Friend Author",
            github="https://github.com/friend",
            host="http://127.0.0.1:8000",
            user=self.friend
        )
        # Establish the two users are friends
        self.author.following.add(self.friend_author)
        self.friend_author.following.add(self.author)
        
        
        self.follower = User.objects.create_user(username="follower", password="followerpass")
        self.follower_author = Author.objects.create(
            id=uuid.uuid4(),
            username="follower",
            display_name="Follower Author",
            github="https://github.com/follower",
            host="http://127.0.0.1:8000",
            user=self.follower
        )
        # Follower follows the owner 
        self.follower_author.following.add(self.author)

        self.nonrelation = User.objects.create_user(username="nonrelation", password="nonrelationpass")
        self.nonrelation_author = Author.objects.create(
        id=uuid.uuid4(),
        username="nonrelation",
        display_name="Nonrelation Author",
        github="https://github.com/nonrelation",
        host="http://127.0.0.1:8000",
        user=self.nonrelation
        )

        self.public_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Owner Public Post",
            visibility="PUBLIC",
            content_type="text/plain"
        )
        self.unlisted_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Owner Unlisted Post",
            visibility="UNLISTED",
            content_type="text/plain"
        )
        self.friends_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Owner Friends-Only Post",
            visibility="FRIENDS",
            content_type="text/plain"
        )
        self.deleted_post = Post.objects.create(
            id=uuid.uuid4(),
            author=self.author,
            content="Owner Deleted Post",
            visibility="DELETED",
            content_type="text/plain"
        )
    
    def test_create_public_post(self):
        """
        Testing user story: As an author, I want to be able to make my posts "public", so that everyone can see them.
        """
        self.assertEqual(self.public_post.visibility, "PUBLIC")

    def test_create_unlisted_post(self):
        """
        Testing user story: As an author, I want to be able to make my posts "unlisted," so that my followers see them,
        and anyone with the link can also see them.
        """
        self.assertEqual(self.unlisted_post.visibility, "UNLISTED")
    
    def test_create_friends_only_post(self):
        """
        Testing user story: As an author, I want to be able to make my posts "friends-only," so that I don't have to 
        worry about people I don't know seeing them.
        """
        self.assertEqual(self.friends_post.visibility, "FRIENDS")
    
    def test_friends_see_posts(self):
        """
        Testing user story: As an author, I want my friends to see my friends-only, unlisted, and public posts in their stream.
        """
        url = reverse("author_posts", args=[self.author.id])
        self.client.login(username="friend", password="friendpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        #<BEGIN GENERATED model="gpt-4" date=2025-03-08 prompt: how can i test that a user who is a friend can see publuc, unlisted, and friends-only posts when testing though api becuase if is returned in json format?>
        texts = [post["content"] for post in response.data["src"]]  # type:ignore
        self.assertIn("Owner Public Post", texts)
        self.assertIn("Owner Unlisted Post", texts)
        self.assertIn("Owner Friends-Only Post", texts)
        #<END GENERATED></END>.

    def test_following_see_posts(self):
        """
        Testing user story: As an author, I want anyone following me to see my unlisted and public posts in their stream.
        """
        url = reverse("author_posts", args=[self.author.id])
        self.client.login(username="follower", password="followerpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        texts = [post["content"] for post in response.data["src"]]  # type:ignore
        self.assertIn("Owner Public Post", texts)
        self.assertIn("Owner Unlisted Post", texts)
        self.assertNotIn("Owner Friends-Only Post", texts)

    def test_everyone_see_public_posts_in_stream(self):
        """
        Testing user story: As an author, I want everyone to see my public posts in their stream.
        """
        index_url = reverse("index")

        # shows up in owner's stream
        self.client.login(username="owner", password="ownerpass")
        response_owner = self.client.get(index_url)
        self.assertEqual(response_owner.status_code, 200)
        self.assertContains(response_owner, self.public_post.content) # type:ignore
        self.client.logout()

        # shows up in friend's stream
        self.client.login(username="friend", password="friendpass")
        response_friend = self.client.get(index_url)
        self.assertEqual(response_friend.status_code, 200)
        self.assertContains(response_friend, self.public_post.content) # type:ignore
        self.client.logout()

         # shows up in follower's stream
        self.client.login(username="follower", password="followerpass")
        response_friend = self.client.get(index_url)
        self.assertEqual(response_friend.status_code, 200)
        self.assertContains(response_friend, self.public_post.content) # type:ignore
        self.client.logout()

        self.client.login(username="nonrelation", password="nonrelationpass")
        response_other = self.client.get(index_url)
        self.assertEqual(response_other.status_code, 200)
        self.assertContains(response_other, self.public_post.content) # type:ignore
        self.client.logout()
        
        # shows up in unauthentcated stream
        self.client.logout()
        response_unauth = self.client.get(index_url)
        self.assertEqual(response_unauth.status_code, 200)
        self.assertContains(response_unauth, self.public_post.content) # type:ignore
    
    def test_everyone_see_public_and_unlisted_if_link(self):
        """
        Testing user story: As an author, I want everyone to be able to see my public and unlisted posts, 
        if they have a link to it.
        """
        # url from api for posts
        url_public = reverse("posts_detail", args=[self.author.id, self.public_post.id])
        url_unlisted = reverse("posts_detail", args=[self.author.id, self.unlisted_post.id])

        # unathenticated user can access
        self.client.logout()
        response_public = self.client.get(url_public)
        response_unlisted = self.client.get(url_unlisted)
        self.assertEqual(response_public.status_code, status.HTTP_200_OK)
        self.assertEqual(response_unlisted.status_code, status.HTTP_200_OK)

        # friend can access
        self.client.login(username="friend", password="friendpass")
        response_public = self.client.get(url_public)
        response_unlisted = self.client.get(url_unlisted)
        self.assertEqual(response_public.status_code, status.HTTP_200_OK)
        self.assertEqual(response_unlisted.status_code, status.HTTP_200_OK)
        self.client.logout()

        # follower can access
        self.client.login(username="follower", password="followerpass")
        response_public = self.client.get(url_public)
        response_unlisted = self.client.get(url_unlisted)
        self.assertEqual(response_public.status_code, status.HTTP_200_OK)
        self.assertEqual(response_unlisted.status_code, status.HTTP_200_OK)
        self.client.logout()

        # non friend non folower can access
        self.client.login(username="nonrelation", password="nonrelationpass")
        response_public = self.client.get(url_public)
        response_unlisted = self.client.get(url_unlisted)
        self.assertEqual(response_public.status_code, status.HTTP_200_OK)
        self.assertEqual(response_unlisted.status_code, status.HTTP_200_OK)
        self.client.logout()

    def test_non_friend_visibility_of_friends_only_post(self):
        """
        Testing user story: As an author, I don't anyone who isn't a friend to be able to see my friends-only posts and images, 
        so I can feel safe about posting.
        """
        url = reverse("posts_detail", args=[self.author.id, self.friends_post.id])

        # friend can access
        self.client.login(username="friend", password="friendpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.client.logout()

        # follower can not access
        self.client.login(username="follower", password="followerpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # non friend non folower can not access
        self.client.login(username="nonrelation", password="nonrelationpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # unathenticated user cannot access
        self.client.logout()
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_no_one_see_deleted_post(self):
        """
        Testing user story: As an author, I don't want anyone except the node admin to see my deleted posts.
        """
        url = reverse("posts_detail", args=[self.author.id, self.deleted_post.id])

        # I can't see my deleted posts
        self.client.login(username="owner", password="ownerpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # friedn cannot access
        self.client.login(username="friend", password="friendpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # follower can not access
        self.client.login(username="follower", password="followerpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # non friend non folower can not access
        self.client.login(username="nonrelation", password="nonrelationpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.client.logout()

        # unathenticated user cannot access
        self.client.logout()
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_owner_post_visible_until_deleted(self):
        """
        Testing user story: As an author, posts I create should always be visible to me until they are deleted, 
        so I can find them to edit them or review them or get the link or whatever I want to do with them.
        """
        url = reverse("author_posts", args=[self.author.id])
        self.client.login(username="owner", password="ownerpass")
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        texts = [post["content"] for post in response.data["src"]]  # type:ignore
        self.assertIn("Owner Public Post", texts)
        self.assertIn("Owner Unlisted Post", texts)
        self.assertIn("Owner Friends-Only Post", texts)
        self.assertNotIn("Owner Deleted Post", texts)
