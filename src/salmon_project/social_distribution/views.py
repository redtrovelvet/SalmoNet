#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from .models import Author, Post, FollowRequest, Comment, CommentLike, PostLike, NodeInfo, RemoteNode
from .serializers import AuthorSerializer, PostSerializer, CommentSerializer, CommentLikeSerializer, PostLikeSerializer
from django.conf import settings
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.hashers import make_password, check_password
from django.http import HttpResponseForbidden, HttpResponse, JsonResponse
from django.utils.html import escape

# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.contrib.auth.decorators import user_passes_test
from django.views.decorators.http import require_POST, require_http_methods
from django.core.paginator import Paginator
import commonmark, uuid, mimetypes, requests
from urllib.parse import unquote
from django.utils.dateparse import parse_datetime
import requests
from urllib.parse import urlparse

# Create your views here.
def index(request):
    if request.user.is_authenticated:
        current_author = get_object_or_404(Author, username=request.user.username)
        # Get posts from authors that current_author follows
        posts = Post.objects.filter(author=current_author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
        for author in current_author.following.all():
            if current_author in author.following.all():
                # Mutual follow (friends): include PUBLIC, UNLISTED, and FRIENDS posts
                author_posts = Post.objects.filter(author=author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
            else:
                # Not mutual: only include PUBLIC and UNLISTED posts
                author_posts = Post.objects.filter(author=author).exclude(visibility__in=["FRIENDS", "DELETED"])
            posts |= author_posts

        # Also include public posts from all other authors (to widen the feed)
        public_posts = Post.objects.filter(visibility="PUBLIC")
        posts = (posts | public_posts).distinct().order_by("-created_at")
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        current_author = None

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    # Convert posts to a new list with rendered text if needed
    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_text = escape(p.text)
        html_text = render_markdown_if_needed(safe_text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })
    context = {"posts": rendered_posts, "author": current_author}

    # Check for alert message
    if "homepage_alert_message" in request.session:
        alert_message = request.session.pop("homepage_alert_message")
        context["alert_message"] = alert_message

    return render(request, "social_distribution/index.html", context)

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    post_author = get_object_or_404(Author, id=author_id)

    # Attempt to get author object from current user
    try:
        current_user = request.user.author
    except AttributeError:
        current_user = None

    if current_user is not None and current_user.id == post_author.id:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_friends_with(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_following(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "UNLISTED"]).order_by("-created_at")
    else:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC"]).order_by("-created_at")        

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_text = escape(p.text)
        html_text = render_markdown_if_needed(safe_text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })

    return render(request, "social_distribution/profile.html", {
        "author": post_author,
        "posts": rendered_posts
    })

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if not request.user.is_authenticated or request.user != author.user:
        return HttpResponseForbidden("You are not allowed to edit this profile.")
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)
        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        if form.is_valid():
            user = form.save()
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
            else:
                Author.objects.create(user=user, username=user.username, is_approved=False)
                messages.success(request, "Your account has been created and is pending admin approval.")
                return redirect("login")
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})


@user_passes_test(lambda u: u.is_superuser)  # Restrict to superusers (admins)
def admin_approval(request):
    pending_authors = Author.objects.filter(is_approved=False)
    return render(request, "social_distribution/admin_approval.html", {"pending_authors": pending_authors})

@user_passes_test(lambda u: u.is_superuser)
def approve_author(request, author_id):
    author = get_object_or_404(Author, id=author_id)
    author.is_approved = True
    author.save()
    messages.success(request, f"{author.username} has been approved.")
    return redirect("admin_approval")

@user_passes_test(lambda u: u.is_superuser)
def reject_author(request, author_id):
    author = get_object_or_404(Author, id=author_id)
    author.delete()  # Or deactivate the user instead of deleting
    messages.success(request, f"{author.username} has been rejected.")
    return redirect("admin_approval")

def pending_approval(request):
    return render(request, "social_distribution/pending_approval.html")

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            try:
                author = Author.objects.get(user=user)
                if not author.is_approved:
                    return redirect("pending_approval")
            except Author.DoesNotExist:
                messages.error(request, "Author profile not found.")
                return redirect("login")
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

def view_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    post_author = get_object_or_404(Author, id=author_id)
    serialized_post = PostSerializer(post).data
    safe_text = escape(post.text)
    html_text = render_markdown_if_needed(safe_text, post.content_type)
    post_comments = serialized_post["comments"]["src"]
    comments = []
    for comment in post_comments:
        comment["id"] = comment["id"].split("/")[-1]
        comments.append(comment)

    # Convert the post ot a new list with rendered text if needed
    rendered_post = {
        "id": post.id,
        "author": post.author,
        "text": html_text,
        "image": post.image,
        "video": post.video,
        "visibility": post.visibility,
        "created_at": post.created_at,
        "comments": comments,
        "likes": serialized_post["likes"],
    }

    # Attempt to get author object from current user
    try:
        current_user = request.user.author

    # If current user is not signed in
    except AttributeError:
        current_user = request.user
        if post.visibility == "FRIENDS":
            request.session["homepage_alert_message"] = "403 Error: Access denied due to not being signed-in"
            return redirect("index")
        
    # If current user is signed in, check access
    else:
        if post.visibility == "FRIENDS" and not (current_user == post_author or post_author.is_friends_with(current_user)):
            request.session["homepage_alert_message"] = "403 Error: Access denied due to not being friends with post's author"
            return redirect("index")
    return render(request, "social_distribution/view_post.html", {"post": rendered_post, "current_user": current_user})

def render_markdown_if_needed(text, content_type):
    """
    If content_type is 'text/markdown', convert 'text' to HTML using commonmark.
    Otherwise, return the text as-is (plain text).
    """
    if content_type == "text/markdown":
        return commonmark.commonmark(text or "")
    return text or "" 

def admin_controls(request):
    if not request.user.is_superuser:
        return redirect("index")

    node_info = NodeInfo.objects.first()
    if node_info:
        username = node_info.username
    else:
        username = ""
    
    return render(request, "social_distribution/admin_controls.html", {"nodes": RemoteNode.objects.all(), "username": username})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def edit_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to edit this post.")
    if request.method == "GET":
        return render(request, "social_distribution/edit_post.html", {"post": post})
    data = request.POST.copy()

    # If user checked "Remove Image", ensure data contains image as None.
    if "remove_image" in data:
        data["image"] = None
    else:
        # Only remove the key if no new file is uploaded.
        image_val = data.get("image", "")
        if image_val is None or (isinstance(image_val, str) and not image_val.strip()):
            # Only pop if the remove checkbox was NOT checked.
            data.pop("image", None)

    # Similarly for video.      
    if "remove_video" in data:
        data["video"] = None
    else:
        video_val = data.get("video", "")
        if video_val is None or (isinstance(video_val, str) and not video_val.strip()):
            data.pop("video", None)

    serializer = PostSerializer(post, data=data, partial=True)
    if serializer.is_valid():
        # If new files are uploaded, attach them.
        if "image" in request.FILES:
            serializer.validated_data["image"] = request.FILES["image"]  # type:ignore
        if "video" in request.FILES:
            serializer.validated_data["video"] = request.FILES["video"]  # type:ignore
        serializer.save()
        return redirect("profile", author_id=author_id)
    else:
        return render(request, "social_distribution/edit_post.html", {"post": post, "serializer": serializer})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def delete_post_local(request, author_id, post_id):
    """
    Local view to delete a post via an HTML confirmation page.
    GET: Render delete_post.html to confirm deletion, passing rendered_text.
    POST: Instead of deleting the post, mark its visibility as "DELETED" and redirect to the profile page.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to delete this post.")
    
    if request.method == "GET":
        safe_text = escape(post.text)
        rendered_text = render_markdown_if_needed(safe_text, post.content_type)
        return render(request, "social_distribution/delete_post.html", {"post": post, "rendered_text": rendered_text, "author": post.author})
    
    post.visibility = "DELETED"
    post.save()
    return redirect("profile", author_id=author_id)

# --- API Endpoints ---

@api_view(["POST"])
def set_node_info(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        node_info = NodeInfo.objects.first()
        if node_info:
            node_info.username = request.POST["username"]
            node_info.password = make_password(request.POST["password"])
            node_info.host = settings.BASE_URL
            node_info.save()
            return Response("Node info updated", status=200)
        else:
            NodeInfo.objects.create(
                host=settings.BASE_URL,
                username=request.POST["username"],
                password=make_password(request.POST["password"])
            )
            return Response("Node info created", status=201)
        
    return Response("GET request not allowed", status=405)

@api_view(["POST"])
def add_remote_node(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        node = RemoteNode.objects.filter(host=request.POST["host"]).first()
        if node:
            node.outgoing = True
            node.save()
            return Response("Node updated", status=200)
        else:
            RemoteNode.objects.create(
                host=request.POST["host"],
                outgoing=True,
                incoming=False
            )
            return Response("Node added", status=201)
    
    return Response("GET request not allowed", status=405)

@api_view(["POST"])
def connect_node(request):
    if request.method == "POST":
        local_node = NodeInfo.objects.first()
        if not local_node:
            return Response("Local node not found", status=404)

        if request.META.get("HTTP_ORIGIN") == local_node.host:
            return Response("Forbidden", status=403)
        
        username = request.POST["username"]
        password = request.POST["password"]

        if local_node.username == username and check_password(password, local_node.password):
            remote_node = RemoteNode.objects.filter(host=request.META.get("HTTP_ORIGIN")).first()
            if remote_node:
                remote_node.incoming = True
                remote_node.save()
                return Response("Connected", status=200)
            else:
                RemoteNode.objects.create(
                    host=request.META.get("HTTP_ORIGIN"),
                    outgoing=False,
                    incoming=True
                )
                return Response("Connected", status=201)
        return Response("Unauthorized", status=401)
            
@api_view(["POST"])
def remove_connection(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        remote_node = RemoteNode.objects.filter(host=request.POST["host"]).first()
        if remote_node:
            remote_node.outgoing = False
            remote_node.save()
            return Response("Outgoing connection removed", status=200)
        return Response("Connection not found", status=404)

'''
@api_view(["GET"])
def get_authors(request):
    API: returns all authors in local node
    
    page_num = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    authors_qs = Author.objects.all().order_by("id")
    paginator = Paginator(authors_qs, size)
    page_obj = paginator.get_page(page_num)

    serializer = AuthorSerializer(page_obj, many=True)
    return Response({
        "type": "authors",
        "authors": serializer.data  
    })
'''

@api_view(["GET"])
def get_authors(request):
    """
    API: returns all authors on this local node
    """
    page_num = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    authors_qs = Author.objects.filter(host=settings.BASE_URL).order_by("id")
    paginator = Paginator(authors_qs, size)
    page_obj = paginator.get_page(page_num)

    serializer = AuthorSerializer(page_obj, many=True)
    return Response({
        "type": "authors",
        "authors": serializer.data
    })

@api_view(["GET", "PUT"])
def author_details(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        serializer = AuthorSerializer(author)
        return Response(serializer.data)
    
    if request.method == "PUT":
        if not request.user.is_authenticated or request.user.author != author:
            return Response({"detail": "Forbidden"}, status=403)

        serializer = AuthorSerializer(author, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)
    
@api_view(["GET"])
def fqid_author_details(request, author_fqid):
    '''
    API: returns specific author detaisl using fqid.
    works for both local and remote (percent encoded path)
    '''
    decoded_fqid = unquote(author_fqid)
    author = get_object_or_404(Author, fqid=decoded_fqid)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)

@require_POST
def send_follow_request(request, author_id):
    # View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')
    current_author = request.user.author

    try:
        target_author = Author.objects.get(id=author_id)
    except Author.DoesNotExist:
        target_author = get_object_or_404(Author, fqid=author_id)

    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)
    
    if target_author.host != settings.BASE_URL:
        follow_request_data = {
            "type": "follow",
            "summary": f"{current_author.display_name} wants to follow {target_author.display_name}",
            "actor": AuthorSerializer(current_author).data,
        }

        try:
            remote_inbox_url = f"{target_author.host}/api/authors/{target_author.fqid}/inbox/"
            response = requests.post(remote_inbox_url, json=follow_request_data, timeout=10)
            if response.status_code in [200, 201]:
                current_author.following.add(target_author)
                messages.success(request, f"Follow request sent to remote author {target_author.display_name}.")
            else:
                messages.error(request, f"Failed to send follow request to remote author: {response.text}")
        except Exception as e:
            messages.error(request, f"Error sending follow request to remote author: {str(e)}")
        return redirect('profile', author_id=target_author.id)
    else:
        FollowRequest.objects.create(sender=current_author, receiver=target_author)
        current_author.following.add(target_author)
        messages.success(request, f"Follow request sent to {target_author.display_name}.")
        return redirect('profile', author_id=target_author.id)
        
    
def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.filter(host=settings.BASE_URL)
    authors = list(authors)
    
    for author in authors:
        author.page = f"/authors/{author.id}/"

    remote_nodes = RemoteNode.objects.filter(incoming=True, outgoing=True).exclude(host=settings.BASE_URL)
    for node in remote_nodes:
        response = requests.get(f"{node.host}/api/authors/")
        if response.status_code == 200:
            remote_authors = response.json()["authors"]
            for remote_author in remote_authors:
                remote_author["host"] = node.host
                remote_author["fqid"] = remote_author["id"]
                remote_author["display_name"] = remote_author["displayName"]
                remote_author["username"] = remote_author["displayName"]

                remote_author_obj, _  = Author.objects.get_or_create(
                fqid=remote_author["fqid"],
                defaults={
                    "username": remote_author["displayName"],
                    "display_name": remote_author["displayName"],
                    "host": node.host,
                    "is_approved": False,
                    "user": None,  # no associated Django user
                    "profile_image": remote_author["profileImage"]
                }
                )  
                if remote_author_obj not in authors:
                    authors.append(remote_author_obj)

    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')
    
    notifications = []
    
    # Notifications for likes on posts
    post_like_qs = PostLike.objects.filter(object__author=current_author)
    for like in post_like_qs:
        notifications.append({
            "type": "like",
            "author": {
                "display_name": like.author.display_name,
                "username": like.author.username  # Include username explicitly
            },
            "published": like.published,
            "post_url": f"{like.object.author.host}/authors/{like.object.author.id}/posts/{like.object.id}/view/"
        })
    
    # Notifications for likes on comments on posts owned by the current user.
    comment_like_qs = CommentLike.objects.filter(object__post__author=current_author)
    for like in comment_like_qs:
        notifications.append({
            "type": "like_comment",
            "author": {
                "display_name": like.author.display_name,
                "username": like.author.username  # Include username explicitly
            },
            "published": like.published,
            "liked_comment": like.object.comment,
            "post_url": f"{like.object.post.author.host}/authors/{like.object.post.author.id}/posts/{like.object.post.id}/view/"
        })
    
    # Notifications for new comments on posts owned by the current user.
    comment_qs = Comment.objects.filter(post__author=current_author).exclude(author=current_author)
    for comment in comment_qs:
        notifications.append({
            "type": "comment",
            "author": {
                "display_name": comment.author.display_name,
                "username": comment.author.username  # Include username explicitly
            },
            "comment": comment.comment,
            "published": comment.published,
            "post_url": f"{comment.post.author.host}/authors/{comment.post.author.id}/posts/{comment.post.id}/view/"
        })
    
    following_notifications = []
    # Limit to the 5 latest posts by followed authors
    following_posts = Post.objects.filter(author__in=current_author.following.all()).exclude(author=current_author).order_by("-created_at")[:5]
    for post in following_posts:
        following_notifications.append({
            "type": "following_post",
            "author": {
                "display_name": post.author.display_name,
                "username": post.author.username  # Include username explicitly
            },
            "published": post.created_at,
            "post_url": f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/view/"
        })
    
    # Sort notifications by published date descending (latest first)
    notifications.sort(key=lambda n: n["published"], reverse=True)
    
    return render(request, "social_distribution/follow_requests.html", {
        "follow_requests": follow_requests,
        "like_notifications": notifications,
        "following_notifications": following_notifications  
    })

@require_POST
def approve_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'ACCEPTED'
    follow_request.save()
    follow_request.sender.following.add(receiver)
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors') # You can also redirect to another page if preferred.

@require_POST
def deny_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')

def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    current_author.following.remove(target_author)
    from .models import FeedBlock  
    FeedBlock.objects.get_or_create(blocker=current_author, blocked_author=target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name} and blocked their posts from your feed.")
    return redirect('profile', author_id=target_author.id)

def view_followers(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your followers.")
        return redirect('login')
    current_author = request.user.author
    followers = Author.objects.filter(following=current_author)
    return render(request, "social_distribution/followers.html", {"followers": followers})

# View to display authors that the current user follows
def view_following(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view who you're following.")
        return redirect('login')
    current_author = request.user.author  # Current user’s Author profile
    following = current_author.following.all()
    return render(request, "social_distribution/following.html", {"following": following})

def view_friends(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your friends.")
        return redirect('login')
    current_author = request.user.author
    following = set(current_author.following.all())
    followers = set(Author.objects.filter(following=current_author))
    friends = following.intersection(followers)
    return render(request, "social_distribution/friends.html", {"friends": friends})

@api_view(['GET', 'DELETE', 'PUT'])
def posts_detail(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    Friends-only posts: must be authenticated and must be a friend.
    DELETE [local] remove a local posts: must be authenticated locally as the author
    PUT [local] update a post
    local posts: must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    author = post.author

    if request.method == "GET":
        # If post is marked DELETED, don't allow retrieval.
        if post.visibility == "DELETED":
            return Response({"detail": "Post not found."}, status=403)
        
        # For FRIENDS-only posts, enforce friendship check.
        if post.visibility == "FRIENDS":
            if not request.user.is_authenticated:
                return Response({"detail": "Authentication required."}, status=403)
            try:
                requesting_author = request.user.author
            except Author.DoesNotExist:
                return Response({"detail": "Authentication required."}, status=403)
            # Must be mutual friends.
            if (requesting_author not in author.following.all() or
                    author not in requesting_author.following.all()):
                return Response({"detail": "You are not friends with the author."}, status=403)
        serializer = PostSerializer(post)
        return Response(serializer.data)
    
    elif request.method == "DELETE":
        # Only the author can delete their post.
        if author.user != request.user:
            return Response(status=403)
        post.visibility = "DELETED"
        post.save()
        return Response(status=204)
    
    elif request.method == "PUT":
        # Only the author can update their post.
        if author.user != request.user:
            return Response(status=403)
        serializer = PostSerializer(post, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_by_fqid(request, post_fqid):
    """
    GET [remote] get the public post whose URL is POST_FQID
    Friends-only posts: must be authenticated and must be a friend.
    """
    decoded_fqid = unquote(post_fqid)
    post = get_object_or_404(Post, fqid=decoded_fqid)
    author = post.author

    # If post is marked DELETED, don't allow retrieval.
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)
    
    # For FRIENDS-only posts, enforce friendship check.
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)
        # Check mutual friendship
        if (requesting_author not in author.following.all() or
                author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET',"POST"])
def author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)

    if request.method == "GET":
        posts = Post.objects.filter(author=author).exclude(visibility="DELETED")
        if not request.user.is_authenticated:
            # Not logged in: show only public posts.
            posts = posts.filter(visibility='PUBLIC')
        elif request.user.author == author:
            # Viewing your own profile: show all posts.
            pass  
        else:
            current_author = request.user.author
            if author in current_author.following.all():
                # Check if current_author and author are mutual followers (i.e. friends).
                if current_author in author.following.all() and author in current_author.following.all():
                    # They are friends: allow public, unlisted, and friends-only posts.
                    posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED', 'FRIENDS'])
                else:
                    # One-way following: show public and unlisted posts.
                    posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED'])
            else:
                # Not mutual friends: show only public posts.
                posts = posts.filter(visibility='PUBLIC')
        serializer = PostSerializer(posts, many=True)
        return Response(serializer.data)
    
    elif request.method == "POST":
        author = get_object_or_404(Author, id=author_id)
        if author.user != request.user:
            return Response(status=403)
        serializer = PostSerializer(data=request.data, context={'author': author})
        if serializer.is_valid():
            serializer.save(author=author)
            return Response(serializer.data)
        return Response(serializer.errors, status=400)
        
    
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(data=request.data, context={'author': author})
    if serializer.is_valid():
        serializer.save(author=author)
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/profile.html")

@api_view(['GET'])
def get_post_image(request, author_id, post_id):
    """
    GET [local]: get the public post converted to binary as an image.
    Return 404 if not an image.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)

    # Check DELETED visibility
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)

    # Check if the post has an image
    if not post.image:
        return Response({"detail": "Post does not have an image."}, status=404)

    # FRIENDS-only visibility logic
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)

        if (requesting_author not in post.author.following.all() or
                post.author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)

    # Dynamically detect image content type
    mime_type, _ = mimetypes.guess_type(post.image.url)
    if mime_type not in ["image/png", "image/jpeg"]:
        return Response({"detail": "Not a valid image type."}, status=404)

    with post.image.open('rb') as image_file:
        binary_image_data = image_file.read()

    return HttpResponse(binary_image_data, content_type=mime_type)

@api_view(['GET'])
def get_postimage_by_fqid(request, post_fqid):
    """
    GET [remote]: get the public post converted to binary as an image.
    Return 404 if not an image.
    """
    decoded_fqid = unquote(post_fqid)
    post = get_object_or_404(Post, fqid=decoded_fqid)

    # Check DELETED visibility
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)

    # Check if the post has an image
    if not post.image:
        return Response({"detail": "Post does not have an image."}, status=404)

    # FRIENDS-only visibility logic
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)

        if (requesting_author not in post.author.following.all() or
                post.author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)

    # Dynamically detect image content type
    mime_type, _ = mimetypes.guess_type(post.image.url)
    if mime_type not in ["image/png", "image/jpeg"]:
        return Response({"detail": "Not a valid image type."}, status=404)

    with post.image.open('rb') as image_file:
        binary_image_data = image_file.read()

    return HttpResponse(binary_image_data, content_type=mime_type)

# ================= NEW: Followers and Follow Request API Endpoints =================

@api_view(["GET"])
def get_followers_api(request, author_id):
    """
    API: GET /api/authors/{author_id}/followers/
    Returns a JSON object with a list of authors who follow the given author.
    """
    author = get_object_or_404(Author, id=author_id)
    followers = Author.objects.filter(following=author)
    serializer = AuthorSerializer(followers, many=True)
    return Response({
        "type": "followers",
        "followers": serializer.data
    })

def is_remote(request):
    incoming_host = request.get_host()  # e.g., "[2605:fd00:4:1001:f816:3eff:fe2c:1382]"
    expected_host = urlparse(settings.BASE_URL).netloc  # strips 'http://' and gives same format
    return incoming_host != expected_host

@api_view(["POST"])
def inbox(request, author_id):
    data = request.data
    receiver = get_object_or_404(Author, id=author_id)

    # === FOLLOW REQUEST === 
    if data.get("type") == "follow":
        actor_data = data.get("actor")
        if not actor_data:
            return Response({"detail": "Missing actor data."}, status=400)
        
        sender_fqid = actor_data.get("id")
        try:
            sender = Author.objects.get(fqid=sender_fqid)
        except Author.DoesNotExist:
            return Response({"detail": "Sender author not found in database."}, status=404)
        
        follow_req, created = FollowRequest.objects.get_or_create(sender=sender, receiver=receiver, defaults={"status": "PENDING"})

        if created:
            return Response({"detail": "Follow request created."}, status=201)
        else:
            return Response({"detail": "Follow request already exists."}, status=200)

    # Handling likes, comments from a local node
    elif not is_remote(request):

        # === POST LIKE ===
        if data.get("type") == "like":
            actor_data = data.get("actor")
            if not actor_data:
                return Response({"detail": "Missing actor data."}, status=400)
            sender_id = actor_data.get("id")
            try:
                sender_uuid = uuid.UUID(sender_id.split("/")[-1])
            except Exception:
                try:
                    sender_uuid = uuid.UUID(sender_id)
                except Exception:
                    return Response({"detail": "Invalid sender id."}, status=400)
            sender = get_object_or_404(Author, id=sender_uuid)
            published = data.get("published")
            post_id = data.get("post_id")
            if not post_id:
                return Response({"detail": "Missing post id."}, status=400)
            post_obj = get_object_or_404(Post, id=post_id)
            post_url = f"{post_obj.author.host}/authors/{post_obj.author.id}/posts/{post_obj.id}/"
            notification = {
                "type": "like_notification",
                "author": AuthorSerializer(sender).data,
                "published": published,
                "post_url": post_url
            }
            return Response({"detail": "Like notification received.", "notification": notification}, status=201)
        
        # === COMMENT ===
        # Expect payload to include: type, actor, post_id, comment, published
        elif data.get("type") == "comment":
            actor_data = data.get("actor")
            if not actor_data:
                return Response({"detail": "Missing actor data."}, status=400)
            sender_id = actor_data.get("id")
            try:
                sender_uuid = uuid.UUID(sender_id.split("/")[-1])
            except Exception:
                try:
                    sender_uuid = uuid.UUID(sender_id)
                except Exception:
                    return Response({"detail": "Invalid sender id."}, status=400)
            sender = get_object_or_404(Author, id=sender_uuid)
            post_id = data.get("post_id")
            if not post_id:
                return Response({"detail": "Missing post id."}, status=400)
            post_obj = get_object_or_404(Post, id=post_id)
            comment_text = data.get("comment")
            if not comment_text:
                return Response({"detail": "Missing comment text."}, status=400)
            published = data.get("published")
            post_url = f"{post_obj.author.host}/authors/{post_obj.author.id}/posts/{post_obj.id}/"
            notification = {
                "type": "comment_notification",
                "author": AuthorSerializer(sender).data,
                "comment": comment_text,
                "published": published,
                "post_url": post_url
            }
            return Response({"detail": "Comment notification received.", "notification": notification}, status=201)
        
        else:
            return Response({"detail": "Unsupported type for inbox."}, status=400)

    elif is_remote(request): # Handling posts, likes and comments from a remote node

        # === LIKE  ===
        if data.get("type") == "like":
            author_data = data.get("author")
            if not author_data:
                return Response({"detail": "Missing author data."}, status=400)
            
            sender_fqid = author_data.get("id")
            try:
                sender = Author.objects.get(fqid=sender_fqid)
            except Author.DoesNotExist:
                return Response({"detail": "Sender author not found in database."}, status=404)
            
            object_fqid = data.get("object")
            if not object_fqid:
                return Response({"detail": "Missing object field."}, status=400)
            
            like_fqid = data.get("id")
            published = data.get("published")
            parsed = urlparse(object_fqid)
            object_path = parsed.path

            # === COMMENT LIKE  ===
            if "/commented/" in object_path:
                try:
                    comment = Comment.objects.get(fqid=object_fqid)
                    Clike, created = CommentLike.objects.get_or_create(fqid=like_fqid,defaults={"object": comment,"author": sender,"published": parse_datetime(published)})
                    if not created:
                        Clike.delete()
                        return Response({"detail": "Comment like removed."}, status=200)
                    return Response({"detail": "Comment like stored."}, status=201)
                except Comment.DoesNotExist:
                    return Response({"detail": "Target comment not found."}, status=404)
                
            # === POST LIKE  ===
            elif "/posts/" in object_path:
                try:
                    post = Post.objects.get(fqid=object_fqid)
                    Plike, created = PostLike.objects.get_or_create(fqid=like_fqid,defaults={"object": post,"author": sender,"published": parse_datetime(published)})
                    if not created:
                        Plike.delete()
                        return Response({"detail": "Post like removed."}, status=200)
                    post_url = f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/"
                    notification = { 
                        "type": "like_notification",
                        "author": AuthorSerializer(sender).data,
                        "published": published,
                        "post_url": post_url
                    }
                    return Response({"detail": "Post like stored.", "notification": notification}, status=201)
                except Post.DoesNotExist:
                    return Response({"detail": "Target post not found."}, status=404)
            else:
                return Response({"detail": "Unrecognized object type for like."}, status=400)
            
        # === COMMENT  === 
        elif data.get("type")=="comment":
            author_data = data.get("author")
            if not author_data:
                return Response({"detail": "Missing author data."}, status=400)

            sender_fqid = author_data.get("id")
            try:
                sender = Author.objects.get(fqid=sender_fqid)
            except Author.DoesNotExist:
                return Response({"detail": "Sender author not found in database."}, status=404)

            post_fqid = data.get("post")
            if not post_fqid:
                return Response({"detail": "Missing post field."}, status=400)

            comment_text = data.get("comment")
            content_type = data.get("contentType")
            published = data.get("published")
            comment_fqid = data.get("id")

            if not comment_text or not comment_fqid:
                return Response({"detail": "Missing comment text or comment fqid."}, status=400)

            try:
                post = Post.objects.get(fqid=post_fqid)
                comment, created = Comment.objects.get_or_create(fqid=comment_fqid, defaults={"post": post, "author": sender, "comment": comment_text, 'content_type': content_type, 'published': parse_datetime(published)})
            except Post.DoesNotExist:
                return Response({"detail": "Target post not found."}, status=404)
            
            # Handle embedded comment likes 
            likes_data = data.get("likes", {}).get("src", [])
            for like in likes_data:
                like_author_data = like.get("author")
                if not like_author_data:
                    continue
                liker_fqid = like_author_data.get("id")
                liker, _ = Author.objects.get_or_create(
                    fqid=liker_fqid,
                    defaults={
                        "host": like_author_data.get("host"),
                        "username": like_author_data.get("displayName"),
                        "display_name": like_author_data.get("displayName"),
                        "profile_image": like_author_data.get("profileImage"),
                        "is_approved": False,
                        "user": None,
                        })
                Clike = CommentLike.objects.get_or_create(fqid=like.get("id"),defaults={"object": comment,"author": liker,"published": parse_datetime(like.get("published"))})[0]

            post_url = f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/" 
            notification = { 
                "type": "comment_notification",
                "author": AuthorSerializer(sender).data,
                "comment": comment.comment,
                "published": comment.published,
                "post_url": post_url
            }
            return Response({"detail": "Comment and embedded likes stored.", "notification": notification}, status=201)

    
@api_view(["GET", "PUT", "DELETE"])
@permission_classes([IsAuthenticated])
def modify_follower_api(request, author_id, foreign_author_encoded=None):
    """
    API endpoint to get, add, or remove a follower for the given author.
    
    GET:
      - If foreign_author_encoded is provided, check if that foreign author (after percent‐decoding)
        is a follower of the author with id=author_id. (If yes, return the author object; if not, 404.)
      - If not provided, return a list of all followers.
    
    PUT:
      - Add the foreign author (provided via percent encoded string) as a follower of the author.
        (Authenticated user must be the owner of the profile.)
    
    DELETE:
      - Remove the foreign author as a follower of the author.
        (Authenticated user must be the owner.)
    """
    import urllib.parse
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        if foreign_author_encoded:
            foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
            try:
                foreign_author = Author.objects.get(fqid=foreign_author_id)
            except Author.DoesNotExist:
                return Response({"detail": "Foreign author not found."}, status=404)
            if author in foreign_author.following.all():
                return Response(AuthorSerializer(foreign_author).data, status=200)
            else:
                return Response({"detail": "Not a follower."}, status=404)
        else:
            followers = Author.objects.filter(following=author)
            data = {
                "type": "followers",
                "followers": AuthorSerializer(followers, many=True).data
            }
            return Response(data, status=200)
    elif request.method == "PUT":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(fqid=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        # To add the follower, we add the author to foreign_author.following.
        foreign_author.following.add(author)
        return Response({"detail": "Follower added."}, status=200)
    elif request.method == "DELETE":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(fqid=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        if author in foreign_author.following.all():
            foreign_author.following.remove(author)
            return Response({"detail": "Follower removed."}, status=200)
        else:
            return Response({"detail": "Foreign author is not a follower."}, status=404)


@api_view(["POST"])
def api_send_follow_request(request, author_id):
    """
    API: send a follow request to the author with id=author_id.
    The authenticated user is taken as the actor.
    Expects a JSON payload containing at least "type": "follow".
    """
    if not request.user.is_authenticated:
        return Response({"detail": "Authentication required."}, status=403)
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    if current_author == target_author:
        return Response({"detail": "You cannot follow yourself."}, status=400)
    if FollowRequest.objects.filter(sender=current_author, receiver=target_author, status="PENDING").exists():
        return Response({"detail": "Follow request already sent."}, status=400)
    follow_req = FollowRequest.objects.create(sender=current_author, receiver=target_author)
    response_data = {
        "type": "follow",
        "summary": f"{current_author.display_name} wants to follow {target_author.display_name}",
        "actor": AuthorSerializer(current_author).data,
        "object": AuthorSerializer(target_author).data
    }
    return Response(response_data, status=201)

# ========================== COMMENTS ==========================
@api_view(["GET"])
def get_comments(request, post_id, author_id=None):
    '''
    API: returns all comments for a post in the form of a "comments" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    # Get the relevant comments based on the post id and optional author id
    if author_id: # use author and post serial
        post_id = uuid.UUID(post_id)
        author_id = uuid.UUID(author_id)
        comments = Comment.objects.filter(post_id=post_id, post__author__id=author_id)
    else: # use post_fqid
        post_fqid = unquote(post_id)
        comments = Comment.objects.filter(post__fqid=post_fqid)
        author_id = Post.objects.get(fqid=post_fqid).author.id
        post_id = Post.objects.get(fqid=post_fqid).id

    paginator = Paginator(comments, size)
    page = paginator.get_page(page_number)
    serialized_comments = CommentSerializer(page, many=True).data
    host = settings.BASE_URL
    comments_data = {
        "type": "comments",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/comments",
        "page_number": page_number,
        "size": min(len(serialized_comments), size),
        "count": len(comments),
        "src": serialized_comments
    }
    return Response(comments_data)

@api_view(["GET", "POST"])
def commented(request, author_id):
    '''
    API: returns all comments made by an author, or allows an author to post a comment
    '''
    if request.method == "POST":
        # Add author id to the serializer data, make a copy of the data because it is immutable
        data = request.data.copy()
        if ("http" in author_id): # use author fqid
            author_id = unquote(author_id)
            author = get_object_or_404(Author, fqid=author_id)
        else: # use author serial
            author_id = uuid.UUID(author_id)
            author = get_object_or_404(Author, id=author_id)
        data["author"] = author.id

        serializer = CommentSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=201)
        return Response(status=400, data=serializer.errors)
    else: # GET based on author fqid
        if ("http" in author_id):
            author_id = unquote(author_id)
            comments = Comment.objects.filter(author__fqid=author_id)
        else: # GET based on author serial
            author_id = uuid.UUID(author_id)
            comments = Comment.objects.filter(author_id=author_id)
        serializer = CommentSerializer(comments, many=True)
        return Response(serializer.data)

@api_view(["GET"])
def get_comment(request, comment_id, author_id=None, post_id=None):
    '''
    API: returns a specific comment
    '''

    # Get the comment based on the comment id
    if author_id:
        if post_id: # use author and post serial and remote comment fqid
            post_id = uuid.UUID(post_id)
            author_id = uuid.UUID(author_id)
            comment_id = unquote(comment_id)
            comment = get_object_or_404(Comment, fqid=comment_id, post__author__id=author_id, post_id=post_id)
        else: # use author and comment serial
            author_id = uuid.UUID(author_id)
            comment_id = uuid.UUID(comment_id)
            comment = get_object_or_404(Comment, id=comment_id, author_id=author_id)
    else: # use comment fqid
        comment_id = unquote(comment_id)
        comment = get_object_or_404(Comment, fqid=comment_id)
    
    # Return the comment
    serializer = CommentSerializer(comment)
    return Response(serializer.data)

# ========================== LIKES ==========================
@api_view(["GET"])
def get_post_likes(request, post_id, author_id=None):
    '''
    API: returns all likes for a post
    '''

    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    if author_id: # use author and post serial
        post_id = uuid.UUID(post_id)
        author_id = uuid.UUID(author_id)
        likes = PostLike.objects.filter(object_id=post_id, object__author__id=author_id)
    else: # use post_fqid
        post_fqid = unquote(post_id)
        likes = PostLike.objects.filter(object__fqid=post_fqid)
        author_id = Post.objects.get(fqid=post_fqid).author.id
        post_id = Post.objects.get(fqid=post_fqid).id
    
    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_comment_likes(request, author_id, post_id, comment_id):
    '''
    API: returns all likes for a comment
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    comment_fqid = unquote(comment_id)
    post_id = uuid.UUID(post_id)
    author_id = uuid.UUID(author_id)
    comment = get_object_or_404(Comment, fqid=comment_fqid, post_id=post_id, post__author__id=author_id)
    likes = CommentLike.objects.filter(object_id=comment.id)
    comment_id = comment.id

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = CommentLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{comment.author.id}/comments/{comment_id}",
        "id": f"{host}/api/authors/{comment.author.id}/commented/{comment_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_author_liked(request, author_id):
    '''
    API: returns all likes made by an author
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    if ("http" in author_id):
        author_fqid = unquote(author_id)
        post_likes = PostLike.objects.filter(author__fqid=author_fqid)
        comment_likes = CommentLike.objects.filter(author__fqid=author_fqid)
        author_id = Author.objects.get(fqid=author_fqid).id
    else:    
        author_id = uuid.UUID(author_id)
        post_likes = PostLike.objects.filter(author_id=author_id)
        comment_likes = CommentLike.objects.filter(author_id=author_id)
    likes = list(post_likes) + list(comment_likes)

    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data
    host = settings.BASE_URL
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/likes",
        "id": f"{host}/api/authors/{author_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_like(request, like_id, author_id=None):
    '''
    API: returns a specific like
    '''
    if author_id: # use author and like serial
        author_id = uuid.UUID(author_id)
        like_id = uuid.UUID(like_id)

        try:
            like = PostLike.objects.get(author_id=author_id, id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(author_id=author_id, id=like_id)
            post = False
    else: # use like fqid
        like_id = unquote(like_id)
        try:
            like = PostLike.objects.get(fqid=like_id)
            post = True
        except:
            like = CommentLike.objects.get(fqid=like_id)
            post = False
    if not like:
        return Response(status=404)
    if post:
        serializer = PostLikeSerializer(like)
    else:
        serializer = CommentLikeSerializer(like)
    return Response(serializer.data)

@api_view(["POST"])
def like_post(request, author_id, post_id):
    '''
    API: allows an author to like a post
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = post_id
        serializer = PostLikeSerializer(data=data)
        if serializer.is_valid():
            if PostLike.objects.filter(author=author_id, object=post_id).exists():
                PostLike.objects.filter(author=author_id, object=post_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
        
    like_count = PostLike.objects.filter(object=post_id).count()
    return Response({"like_count": like_count}, status=201)

@api_view(["POST"])
def like_comment(request, author_id, comment_id):
    '''
    API: allows an author to like a comment
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = comment_id
        serializer = CommentLikeSerializer(data=data)
        if serializer.is_valid():
            if CommentLike.objects.filter(author=author_id, object=comment_id).exists():
                CommentLike.objects.filter(author=author_id, object=comment_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
    
    like_count = CommentLike.objects.filter(object=comment_id).count()
    return Response({"like_count": like_count}, status=201)
