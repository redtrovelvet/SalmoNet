#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from .models import Author, Post, FollowRequest
from .serializers import AuthorSerializer, PostSerializer
from django.conf import settings
from django.http import HttpResponse, JsonResponse
from django.contrib.auth import login, logout, authenticate
# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.views.decorators.http import require_POST

import commonmark

# Create your views here.
def index(request):
    if request.user.is_authenticated:
        author = get_object_or_404(Author, username=request.user.username)
        followed_authors = author.following.all()
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: So in my project there are multiple users and when i go to the homepage, i should be able to see user's posts depending on whether i am logged in to the website. If i am logged in i should see friends, unlisted, and public posts, but if i am not logged i then i should just see public posts. here are my models (screenshot of my models). Please tell me how to write my index method in views.py in order to see the correst stream in homepage>
        posts = Post.objects.filter(author__in=followed_authors, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).exclude(visibility="DELETED").order_by("-created_at")
        public_posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        posts = (posts | public_posts).distinct().order_by("-created_at")
        #<END GENERATED></END>
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")

    # Convert posts to a new list with rendered text if needed
    rendered_posts = []
    for p in posts:
        html_text = render_markdown_if_needed(p.text, p.content_type)
        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
        })

    return render(request, "social_distribution/index.html", {"posts": rendered_posts})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author, visibility="PUBLIC").order_by("-created_at")
    rendered_posts = []
    for p in posts:
        html_text = render_markdown_if_needed(p.text, p.content_type)
        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
        })

    return render(request, "social_distribution/profile.html", {
        "author": author,
        "posts": rendered_posts
    })

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        # https://www.pythontutorial.net/django-tutorial/django-registration/
        if form.is_valid():
            user = form.save()
            #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: when i create a new author using api request, then a user is not linked to it so i have to register the user in order for the user to be able to login, but when i register, i get an error how do i fix?>
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
                #<END GENERATED></END>
            else:
                Author.objects.create(user=user, username=user.username)
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)


@require_POST  # Only allow POST requests
def send_follow_request(request, author_id):
    # NEW: View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')

    current_author = request.user.author  # Current user's Author profile
    target_author = get_object_or_404(Author, id=author_id)

    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)

    # Check if a follow request already exists (optional)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)

    # Create a new follow request
    FollowRequest.objects.create(sender=current_author, receiver=target_author)
    messages.success(request, f"Follow request sent to {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)


def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.all()
    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')  # UPDATED
    return render(request, "social_distribution/follow_requests.html", {"follow_requests": follow_requests})


@require_POST  
def approve_follow_request(request, request_id):
  
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    

    follow_request.status = 'ACCEPTED'
    follow_request.save()
    
   
    follow_request.sender.following.add(receiver)  
    
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')  # You can also redirect to another page if preferred.


@require_POST
def deny_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')


def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    
    current_author = request.user.author  # Get current user's Author profile
    target_author = get_object_or_404(Author, id=author_id)  # Get the target author

    # Remove the target from current user's following set
    current_author.following.remove(target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)

def view_followers(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your followers.")
        return redirect('login')
    current_author = request.user.author  
    
    followers = Author.objects.filter(following=current_author)
    return render(request, "social_distribution/followers.html", {"followers": followers})
  

# View to display authors that the current user follows
def view_following(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view who you're following.")
        return redirect('login')
    current_author = request.user.author  # Current user’s Author profile
    following = current_author.following.all()
    return render(request, "social_distribution/following.html", {"following": following})
    # ^^^ RENDER following.html with the list of following

def view_friends(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your friends.")
        return redirect('login')
    current_author = request.user.author
    following = set(current_author.following.all())
    followers = set(Author.objects.filter(following=current_author))
    friends = following.intersection(followers)
    return render(request, "social_distribution/friends.html", {"friends": friends})@api_view(['GET'])
def get_post(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_post(request, author_id, post_id):
    """
    DELETE [local] remove a local post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    post.delete()
    return Response(status=204)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def edit_post(request, author_id, post_id):
    """
    PUT [local] update a post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(post, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_by_fqid(request, post_fqid):
    """
    GET [local] get the public post whose URL is POST_FQID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_fqid)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET'])
def get_author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    """
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author)

    if not request.user.is_authenticated:
        posts = posts.filter(visibility='PUBLIC')
    elif request.user.author == author:
        pass  # Show all posts
    elif request.user.author in author.following.all():
        posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED'])
    else:
        posts = posts.filter(visibility='PUBLIC')

    serializer = PostSerializer(posts, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(data=request.data, context={'author': author})
    if serializer.is_valid():
        serializer.save(author=author)
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/profile.html")

@api_view(['GET'])
def get_post_image(request, author_id, post_id):
    """
    GET [local, remote] get the public post converted to binary as an image
    return 404 if not an image
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.content_type not in ['image/png', 'image/jpeg']:
        return Response(status=404)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    return Response(post.image.read(), content_type=post.content_type)

def render_markdown_if_needed(text, content_type):
    """
    If content_type is 'text/markdown', convert 'text' to HTML using commonmark.
    Otherwise, return the text as-is (plain text).
    """
    if content_type == "text/markdown":
        return commonmark.commonmark(text or "")
    return text or ""    