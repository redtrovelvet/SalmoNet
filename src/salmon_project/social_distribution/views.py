#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from .models import Author, Post
from .serializers import AuthorSerializer, PostSerializer
from django.conf import settings
from django.http import HttpResponse
from django.contrib.auth import login, logout, authenticate
# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User


# Create your views here.
def index(request):
    if request.user.is_authenticated:
        author = get_object_or_404(Author, username=request.user.username)
        followed_authors = author.following.all()
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: So in my project there are multiple users and when i go to the homepage, i should be able to see user's posts depending on whether i am logged in to the website. If i am logged in i should see friends, unlisted, and public posts, but if i am not logged i then i should just see public posts. here are my models (screenshot of my models). Please tell me how to write my index method in views.py in order to see the correst stream in homepage>
        posts = Post.objects.filter(author__in=followed_authors, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).exclude(visibility="DELETED").order_by("-created_at")
        public_posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        posts = (posts | public_posts).distinct().order_by("-created_at")
        #<END GENERATED></END>
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")

    return render(request, "social_distribution/index.html", {"posts": posts})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author, visibility="PUBLIC").order_by("-created_at")
    return render(request, "social_distribution/profile.html", {"author": author, "posts": posts})

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        # https://www.pythontutorial.net/django-tutorial/django-registration/
        if form.is_valid():
            user = form.save()
            #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: when i create a new author using api request, then a user is not linked to it so i have to register the user in order for the user to be able to login, but when i register, i get an error how do i fix?>
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
                #<END GENERATED></END>
            else:
                Author.objects.create(user=user, username=user.username)
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)


@api_view(['GET'])
def get_post(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_post(request, author_id, post_id):
    """
    DELETE [local] remove a local post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    post.delete()
    return Response(status=204)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_post(request, author_id, post_id):
    """
    PUT [local] update a post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(post, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_by_fqid(request, post_fqid):
    """
    GET [local] get the public post whose URL is POST_FQID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_fqid)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET'])
def get_author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    """
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author)

    if not request.user.is_authenticated:
        posts = posts.filter(visibility='PUBLIC')
    elif request.user.author == author:
        pass  # Show all posts
    elif request.user.author in author.following.all():
        posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED'])
    else:
        posts = posts.filter(visibility='PUBLIC')

    serializer = PostSerializer(posts, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save(author=author)
        return Response(serializer.data, status=201)
    return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_image(request, author_id, post_id):
    """
    GET [local, remote] get the public post converted to binary as an image
    return 404 if not an image
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.content_type not in ['image/png', 'image/jpeg']:
        return Response(status=404)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    return Response(post.image.read(), content_type=post.content_type)