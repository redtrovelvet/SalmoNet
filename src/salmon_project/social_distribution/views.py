#references:
#https://www.pythontutorial.net/django-tutorial/django-registration/
#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .models import Author, Post, FollowRequest
from .serializers import AuthorSerializer
from django.conf import settings
from django.http import HttpResponse, JsonResponse
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.views.decorators.http import require_POST



# Create your views here.
def index(request):
    if request.user.is_authenticated:
        author = get_object_or_404(Author, username=request.user.username)
        followed_authors = author.following.all()
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: So in my project there are multiple users and when i go to the homepage, i should be able to see user's posts depending on whether i am logged in to the website. If i am logged in i should see friends, unlisted, and public posts, but if i am not logged i then i should just see public posts. here are my models (screenshot of my models). Please tell me how to write my index method in views.py in order to see the correst stream in homepage>
        posts = Post.objects.filter(author__in=followed_authors, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).exclude(visibility="DELETED").order_by("-created_at")
        public_posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        posts = (posts | public_posts).distinct().order_by("-created_at")
        #<END GENERATED></END>
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")

    return render(request, "social_distribution/index.html", {"posts": posts})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author, visibility="PUBLIC").order_by("-created_at")
    return render(request, "social_distribution/profile.html", {"author": author, "posts": posts})

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        if form.is_valid():
            user = form.save()
            # Create an Author and link it to the newly created user
            Author.objects.create(user=user, username=user.username)  
            login(request, user)
            return redirect("index")

    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request, author_id):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)


@require_POST  # Only allow POST requests
def send_follow_request(request, author_id):
    # NEW: View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')

    current_author = request.user.author  # Current user's Author profile
    target_author = get_object_or_404(Author, id=author_id)

    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)

    # Check if a follow request already exists (optional)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)

    # Create a new follow request
    FollowRequest.objects.create(sender=current_author, receiver=target_author)
    messages.success(request, f"Follow request sent to {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)


def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.all()
    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    # FIX: Filter by the 'status' field (pending requests have status 'PENDING')
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')  # UPDATED
    return render(request, "social_distribution/follow_requests.html", {"follow_requests": follow_requests})


@require_POST  # Only allow POST requests
def approve_follow_request(request, request_id):
    # NEW: Approve a follow request by its ID
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    # The receiver is the logged-in user’s Author profile
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    
    # Approve the request by setting the status to 'ACCEPTED'
    follow_request.status = 'ACCEPTED'
    follow_request.save()
    
    # FIXED: Instead of adding sender to receiver.following, add receiver to sender.following.
    follow_request.sender.following.add(receiver)  # UPDATED: Correct follow relationship
    
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')  # You can also redirect to another page if preferred.


@require_POST
def deny_follow_request(request, request_id):
    # NEW: Deny a follow request by its ID
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')

# NEW: Unfollow view – allows a logged-in user to unfollow another author.
def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    
    current_author = request.user.author  # Get current user's Author profile
    target_author = get_object_or_404(Author, id=author_id)  # Get the target author

    # Remove the target from current user's following set
    current_author.following.remove(target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)

