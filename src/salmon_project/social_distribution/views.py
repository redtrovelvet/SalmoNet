#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from .models import Author, Post, FollowRequest, Comment, CommentLike, PostLike
from .serializers import AuthorSerializer, PostSerializer, CommentSerializer, CommentLikeSerializer, PostLikeSerializer
from django.conf import settings
from django.contrib.auth import login, logout, authenticate
from django.http import HttpResponseForbidden, HttpResponse, JsonResponse

# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.views.decorators.http import require_POST, require_http_methods
from django.core.paginator import Paginator
import commonmark, uuid

# Create your views here.
def index(request):
    if request.user.is_authenticated:
        current_author = get_object_or_404(Author, username=request.user.username)
        # Get posts from authors that current_author follows
        posts = Post.objects.filter(author=current_author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
        for author in current_author.following.all():
            if current_author in author.following.all():
                # Mutual follow (friends): include PUBLIC, UNLISTED, and FRIENDS posts
                author_posts = Post.objects.filter(author=author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
            else:
                # Not mutual: only include PUBLIC and UNLISTED posts
                author_posts = Post.objects.filter(author=author).exclude(visibility="FRIENDS")
            posts |= author_posts

        # Also include public posts from all other authors (to widen the feed)
        public_posts = Post.objects.filter(visibility="PUBLIC")
        posts = (posts | public_posts).distinct().order_by("-created_at")
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        current_author = None

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    # Convert posts to a new list with rendered text if needed
    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        html_text = render_markdown_if_needed(p.text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })

    
    return render(request, "social_distribution/index.html", {"posts": rendered_posts, "author": current_author})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    post_author = get_object_or_404(Author, id=author_id)

    # Attempt to get author object from current user
    try:
        current_user = request.user.author

    # If current user is not signed in
    except AttributeError:
        current_user = None

    if current_user is not None and current_user.id == post_author.id:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_friends_with(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS"]).order_by("-created_at")
    else:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC"]).order_by("-created_at")        

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        html_text = render_markdown_if_needed(p.text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })

    return render(request, "social_distribution/profile.html", {
        "author": post_author,
        "posts": rendered_posts
    })

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        # https://www.pythontutorial.net/django-tutorial/django-registration/
        if form.is_valid():
            user = form.save()
            #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: when i create a new author using api request, then a user is not linked to it so i have to register the user in order for the user to be able to login, but when i register, i get an error how do i fix?>
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
                #<END GENERATED></END>
            else:
                Author.objects.create(user=user, username=user.username)
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

def view_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    post_author = get_object_or_404(Author, id=author_id)

    serialized_post = PostSerializer(post).data
    html_text = render_markdown_if_needed(post.text, post.content_type)
    post_comments = serialized_post["comments"]["src"]
    comments = []
    for comment in post_comments:
        comment["id"] = comment["id"].split("/")[-1]
        comments.append(comment)

    # Convert the post ot a new list with rendered text if needed
    rendered_post = {
        "id": post.id,
        "author": post.author,
        "text": html_text,
        "image": post.image,
        "video": post.video,
        "visibility": post.visibility,
        "created_at": post.created_at,
        "comments": comments,
        "likes": serialized_post["likes"],
    }

    # Attempt to get author object from current user
    try:
        current_user = request.user.author

    # If current user is not signed in
    except AttributeError:
        current_user = request.user
        if post.visibility == "FRIENDS":
            return HttpResponse(status=403)

    # If current user is signed in, check access
    else:
        if post.visibility == "FRIENDS" and not (current_user == post_author or post_author in current_user.following.all()):
            return HttpResponse(status=403)
        
    return render(request, "social_distribution/view_post.html", {"post": rendered_post, "current_user": current_user})

def render_markdown_if_needed(text, content_type):
    """
    If content_type is 'text/markdown', convert 'text' to HTML using commonmark.
    Otherwise, return the text as-is (plain text).
    """
    if content_type == "text/markdown":
        return commonmark.commonmark(text or "")
    return text or "" 

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def edit_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to edit this post.")

    if request.method == "GET":
        return render(request, "social_distribution/edit_post.html", {"post": post})
    
    data = request.POST.copy()

    # If user checked "Remove Image", ensure data contains image as None.
    if "remove_image" in data:
        data["image"] = None
    else:
        # Only remove the key if no new file is uploaded.
        image_val = data.get("image", "")
        if image_val is None or (isinstance(image_val, str) and not image_val.strip()):
            # Only pop if the remove checkbox was NOT checked.
            data.pop("image", None)

    # Similarly for video.
    if "remove_video" in data:
        data["video"] = None
    else:
        video_val = data.get("video", "")
        if video_val is None or (isinstance(video_val, str) and not video_val.strip()):
            data.pop("video", None)

    serializer = PostSerializer(post, data=data, partial=True)
    if serializer.is_valid():
        # If new files are uploaded, attach them.
        if "image" in request.FILES:
            serializer.validated_data["image"] = request.FILES["image"]
        if "video" in request.FILES:
            serializer.validated_data["video"] = request.FILES["video"]
        serializer.save()
        return redirect("profile", author_id=author_id)
    else:
        return render(request, "social_distribution/edit_post.html", {"post": post, "serializer": serializer})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def delete_post_local(request, author_id, post_id):
    """
    Local view to delete a post via an HTML confirmation page.
    GET: Render delete_post.html to confirm deletion, passing rendered_text.
    POST: Delete the post and redirect to the profile page.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to delete this post.")

    if request.method == "GET":
        rendered_text = render_markdown_if_needed(post.text, post.content_type)
        return render(request, "social_distribution/delete_post.html", {"post": post,"rendered_text": rendered_text,"author": post.author})
    
    # On POST, delete the post and redirect.
    post.delete()
    return redirect("profile", author_id=author_id)



# --- API Endpoints ---

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["PUT"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)


@require_POST  # Only allow POST requests
def send_follow_request(request, author_id):
    # NEW: View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')

    current_author = request.user.author  # Current user's Author profile
    target_author = get_object_or_404(Author, id=author_id)

    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)

    # Check if a follow request already exists (optional)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)

    # Create a new follow request
    FollowRequest.objects.create(sender=current_author, receiver=target_author)
    messages.success(request, f"Follow request sent to {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)


def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.all()
    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')  # UPDATED
    return render(request, "social_distribution/follow_requests.html", {"follow_requests": follow_requests})


@require_POST  
def approve_follow_request(request, request_id):
  
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    

    follow_request.status = 'ACCEPTED'
    follow_request.save()
    
   
    follow_request.sender.following.add(receiver)  
    
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')  # You can also redirect to another page if preferred.


@require_POST
def deny_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')


def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    
    current_author = request.user.author  
    target_author = get_object_or_404(Author, id=author_id)  


    current_author.following.remove(target_author)

   
    from .models import FeedBlock  
    FeedBlock.objects.get_or_create(blocker=current_author, blocked_author=target_author)

    messages.success(request, f"You have unfollowed {target_author.display_name} and blocked their posts from your feed.")
    return redirect('profile', author_id=target_author.id)

def view_followers(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your followers.")
        return redirect('login')
    current_author = request.user.author  
    
    followers = Author.objects.filter(following=current_author)
    return render(request, "social_distribution/followers.html", {"followers": followers})
  

# View to display authors that the current user follows
def view_following(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view who you're following.")
        return redirect('login')
    current_author = request.user.author  # Current userâ€™s Author profile
    following = current_author.following.all()
    return render(request, "social_distribution/following.html", {"following": following})
    # ^^^ RENDER following.html with the list of following

def view_friends(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your friends.")
        return redirect('login')
    current_author = request.user.author
    following = set(current_author.following.all())
    followers = set(Author.objects.filter(following=current_author))
    friends = following.intersection(followers)
    return render(request, "social_distribution/friends.html", {"friends": friends})

def get_post(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_post(request, author_id, post_id):
    """
    DELETE [local] remove a local post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    post.delete()
    return Response(status=204)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_post(request, author_id, post_id):
    """
    PUT [local] update a post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(post, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_by_fqid(request, post_fqid):
    """
    GET [local] get the public post whose URL is POST_FQID
    friends-only posts: must be authenticated
    """
    post = get_object_or_404(Post, id=post_fqid)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET'])
def get_author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    """
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author)

    if not request.user.is_authenticated:
        # Not logged in: show only public posts.
        posts = posts.filter(visibility='PUBLIC')
    elif request.user.author == author:
        # Viewing your own profile: show all posts.
        pass  
    else:
        current_author = request.user.author
        # Check if current_author and author are mutual followers (i.e. friends).
        if current_author in author.following.all() and author in current_author.following.all():
            # They are friends: allow public, unlisted, and friends-only posts.
            posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED', 'FRIENDS'])
        else:
            # Not mutual friends: show only public posts.
            posts = posts.filter(visibility='PUBLIC')

    serializer = PostSerializer(posts, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(data=request.data, context={'author': author})
    if serializer.is_valid():
        serializer.save(author=author)
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/profile.html")

@api_view(['GET'])
def get_post_image(request, author_id, post_id):
    """
    GET [local, remote] get the public post converted to binary as an image
    return 404 if not an image
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.content_type not in ['image/png', 'image/jpeg']:
        return Response(status=404)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    return Response(post.image.read(), content_type=post.content_type)

@api_view(["POST"])
def inbox(request, author_id):
    '''
    TODO: implement then inbox to handle a variety of API calls
    '''
    pass


# ========================== COMMENTS ==========================
@api_view(["GET"])
def get_comments(request, post_id, author_id=None):
    '''
    API: returns all comments for a post in the form of a "comments" object
    GET [local, remote]: the comments on the post {AUTHOR_SERIAL} {POST_SERIAL}
    GET [local, remote]: the comments on the post (that our server knows about) {POST_FQID}
    Body is a "comments" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    # Get the relevant comments based on the post id and optional author id
    if author_id:
        # TODO: implement the author serial thing when doing remote node management
        comments = Comment.objects.filter(post_id=post_id)
    else:
        comments = Comment.objects.filter(post_id=post_id)
        author_id = Post.objects.get(id=post_id).author.id

    # Paginate the comments
    paginator = Paginator(comments, size)
    page = paginator.get_page(page_number)
    serialized_comments = CommentSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the comments object
    comments_data = {
        "type": "comments",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/comments",
        "page_number": page_number,
        "size": min(len(serialized_comments), size),
        "count": len(comments),
        "src": serialized_comments
    }

    return Response(comments_data)

@api_view(["GET", "POST"])
def commented(request, author_id):
    '''
    API: returns all comments made by an author, or allows an author to post a comment
    GET [local, remote] get the list of comments author has made on: {AUTHOR_SERIAL}
        [local] any post
        [remote] public and unlisted posts
        paginated
    POST [local] if you post an object of "type":"comment", it will add your comment to the post whose ID is in the post field
        Then the node you posted it to is responsible for forwarding it to the correct inbox

    GET [local] get the list of comments author has made on any post (that local node knows about) {AUTHOR_FQID}
    body is list of "comment" objects
    '''
    if request.method == "POST":
        # Add author id to the serializer data, make a copy of the data because it is immutable
        data = request.data.copy()
        author = get_object_or_404(Author, id=author_id)
        data["author"] = author.id

        # Create the comment
        serializer = CommentSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return redirect(request.META.get('HTTP_REFERER', 'index'))
        return Response(status=400, data=serializer.errors)
    else: # GET request
        # Get the comments made by the author
        comments = Comment.objects.filter(author_id=author_id)
        serializer = CommentSerializer(comments, many=True)
        return Response(serializer.data)

@api_view(["GET"])
def get_comment(request, comment_id, author_id=None, post_id=None):
    '''
    API: returns a specific comment
    GET [local, remote] get the comment {AUTHOR_SERIAL} {POST_SERIAL} {REMOTE_COMMENT_FQID}
    GET [local, remote] get this comment {AUTHOR_SERIAL} {COMMENT_SERIAL}
    GET [local] get this comment {COMMENT_FQID}
    body is a "comment" object
    '''
    # Get the comment based on the comment id
    if author_id:
        # TODO: implement the author and post serial when doing remote node management
        if post_id:
            comment = get_object_or_404(Comment, id=comment_id)
        else:
            comment = get_object_or_404(Comment, id=comment_id)
    else:
        comment = get_object_or_404(Comment, id=comment_id)
    
    # Return the comment 
    serializer = CommentSerializer(comment)
    return Response(serializer.data)


# ========================== LIKES ==========================
@api_view(["GET"])
def get_post_likes(request, post_id, author_id=None):
    '''
    API: returns all likes for a post
    GET [local, remote] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL {AUTHOR_SERIAL} {POST_SERIAL}
    GET [local] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL {POST_FQID}
    body is a "likes" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    if author_id:
        # TODO: implement the author serial thing when doing remote node management
        likes = PostLike.objects.filter(object=post_id)
    else:
        likes = PostLike.objects.filter(object=post_id)
        author_id = Post.objects.get(id=post_id).author.id

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }

    return Response(likes_data)    

@api_view(["GET"])
def get_comment_likes(request, author_id, post_id, comment_id):
    '''
    API: returns all likes for a comment
    GET [local, remote] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL comment COMMENT_FQID
    body is a "likes" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    
    # TODO: implement the author and post serial thing when doing remote node management
    likes = CommentLike.objects.filter(object=comment_id)

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = CommentLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/comments/{comment_id}", # TODO: maybe change this to user display name
        "id": f"{host}/api/authors/{author_id}/commented/{comment_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }

    return Response(likes_data)
    

@api_view(["GET"])
def get_author_liked(request, author_id):
    '''
    API: returns all likes made by an author
    GET [local, remote] a list of likes by AUTHOR_SERIAL {AUTHOR_SERIAL}
    GET [local] a list of likes by AUTHOR_FQID {AUTHOR_FQID}
    body is a "likes" object
    '''
    # TODO: check if this body should actually be a "likes" object and not a list of "like" objects

    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    # Get the likes made by the author for both posts and comments
    post_likes = PostLike.objects.filter(author=author_id)
    comment_likes = CommentLike.objects.filter(author=author_id)
    likes = list(post_likes) + list(comment_likes)

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/likes", # TODO: maybe change this to user display name
        "id": f"{host}/api/authors/{author_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }

    return Response(likes_data)


@api_view(["GET"])
def get_like(request, like_id, author_id=None):
    '''
    API: returns a specific like
    GET [local, remote] a single like {AUTHOR_SERIAL} {LIKE_SERIAL}
    GET [local] a single like {LIKE_FQID}
    body is a "like" object
    '''
    # Get the like based on the like id, try both posts and comments
    if author_id:
        # TODO: implement the author serial thing when doing remote node management
        try:
            like = PostLike.objects.get(id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(id=like_id)
            post = False
    else:
        try:
            like = PostLike.objects.get(id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(id=like_id)
            post = False
    
    if not like:
        return Response(status=404)

    if post:
        serializer = PostLikeSerializer(like)
    else:
        serializer = CommentLikeSerializer(like)
    return Response(serializer.data)

@api_view(["POST"])
def like_post(request, author_id, post_id):
    '''
    API: allows an author to like a post
    '''
    # Get the data
    data = request.data.copy()

    # Ensure that the request is a like request
    if data.get("type") == "like":
        # Add the author and post to the data
        data["author"] = author_id
        data["object"] = post_id

        # Create the like
        serializer = PostLikeSerializer(data=data)
        if serializer.is_valid():
            # Check if the author has already liked the post, if so, unlike it instead
            if PostLike.objects.filter(author=author_id, object=post_id).exists():
                PostLike.objects.filter(author=author_id, object=post_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    print(e)
    return redirect(request.META.get("HTTP_REFERER", "index"))

@api_view(["POST"])
def like_comment(request, author_id, comment_id):
    '''
    API: allows an author to like a comment
    '''
    # Get the data
    data = request.data.copy()

    # Ensure that the request is a like request
    if data.get("type") == "like":
        # Add the author and comment to the data
        data["author"] = author_id
        data["object"] = comment_id

        # Create the like
        serializer = CommentLikeSerializer(data=data)
        if serializer.is_valid():
            # Check if the author has already liked the comment, if so, unlike it instead
            if CommentLike.objects.filter(author=author_id, object=comment_id).exists():
                CommentLike.objects.filter(author=author_id, object=comment_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    print(e)
    return redirect(request.META.get("HTTP_REFERER", "index"))