#references:
#https://www.pythontutorial.net/django-tutorial/django-registration/
#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .models import Author, Post
from .serializers import AuthorSerializer
from django.conf import settings
from django.http import HttpResponse
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  


# Create your views here.
def index(request):
    if request.user.is_authenticated:
        author = get_object_or_404(Author, username=request.user.username)
        followed_authors = author.following.all()
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: So in my project there are multiple users and when i go to the homepage, i should be able to see user's posts depending on whether i am logged in to the website. If i am logged in i should see friends, unlisted, and public posts, but if i am not logged i then i should just see public posts. here are my models (screenshot of my models). Please tell me how to write my index method in views.py in order to see the correst stream in homepage>
        posts = Post.objects.filter(author__in=followed_authors, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).exclude(visibility="DELETED").order_by("-created_at")
        public_posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        posts = (posts | public_posts).distinct().order_by("-created_at")
        #<END GENERATED></END>
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")

    return render(request, "social_distribution/index.html", {"posts": posts})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author, visibility="PUBLIC").order_by("-created_at")
    return render(request, "social_distribution/profile.html", {"author": author, "posts": posts})

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        if form.is_valid():
            user = form.save()
            # Create an Author and link it to the newly created user
            Author.objects.create(user=user, username=user.username)  
            login(request, user)
            return redirect("index")

    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request, author_id):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)

def follow_author(request, author_id):
    # View to allow the current user to follow another author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')
    
    current_author = request.user.author  # Get the current user’s Author profile
    target_author = get_object_or_404(Author, id=author_id)
    
    # Prevent users from following themselves
    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)
    
    # Add the target author to the current author’s "following" set
    current_author.following.add(target_author)
    messages.success(request, f"You are now following {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)

def unfollow_author(request, author_id):
    # NEW: View to allow the current user to unfollow another author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    
    current_author = request.user.author  # Get the current user’s Author profile
    target_author = get_object_or_404(Author, id=author_id)
    
    # Remove the target author from the current author's following set
    current_author.following.remove(target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)

def all_authors(request):
    # Retrieve all authors from the database
    authors = Author.objects.all()
    return render(request, "social_distribution/all_authors.html", {"authors": authors})


