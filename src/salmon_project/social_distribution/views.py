#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.permissions import IsAuthenticated, AllowAny
from .models import Author, Post, FollowRequest, Comment, CommentLike, PostLike, NodeInfo, RemoteNode
from .serializers import AuthorSerializer, PostSerializer, CommentSerializer, CommentLikeSerializer, PostLikeSerializer
from django.conf import settings
from django.contrib.auth import login, logout, authenticate
from django.http import HttpResponseForbidden, HttpResponse, JsonResponse
from django.utils.html import escape

# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.contrib.auth.decorators import user_passes_test
from django.views.decorators.http import require_POST, require_http_methods
from django.core.paginator import Paginator
import commonmark, uuid, mimetypes, requests, re
from urllib.parse import unquote
from django.utils.dateparse import parse_datetime
from urllib.parse import urlparse
from django.core.cache import cache
import base64

# Create your views here.
def index(request):
    if request.user.is_authenticated:
        current_author = get_object_or_404(Author, username=request.user.username)
        # Get posts from authors that current_author follows
        posts = Post.objects.filter(author=current_author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
        for author in current_author.following.all():
            if current_author in author.following.all():
                # Mutual follow (friends): include PUBLIC, UNLISTED, and FRIENDS posts
                author_posts = Post.objects.filter(author=author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
            else:
                # Not mutual: only include PUBLIC and UNLISTED posts
                author_posts = Post.objects.filter(author=author).exclude(visibility__in=["FRIENDS", "DELETED"])
            posts |= author_posts

        # Also include public posts from all other authors (to widen the feed)
        public_posts = Post.objects.filter(visibility="PUBLIC")
        posts = (posts | public_posts).distinct().order_by("-created_at")
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        current_author = None

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    # Convert posts to a new list with rendered text if needed
    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_content = escape(p.content)
        html_content = render_markdown_if_needed(safe_content, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "raw_content": p.content,      
            "rendered_content": html_content,
            "content_type": p.content_type,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })
    context = {"posts": rendered_posts, "author": current_author}

    # Check for alert message
    if "homepage_alert_message" in request.session:
        alert_message = request.session.pop("homepage_alert_message")
        context["alert_message"] = alert_message

    return render(request, "social_distribution/index.html", context)

def rate_limit(max_requests, time_window):
    def decorator(view_func):
        def wrapper(request, *args, **kwargs):
            key = f'rate_limit:{request.user.id}'
            requests_made = cache.get(key, 0)
            if requests_made >= max_requests:
                return HttpResponse('Too Many Requests', status=429)
            cache.set(key, requests_made + 1, time_window)
            return view_func(request, *args, **kwargs)
        return wrapper
    return decorator

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    post_author = get_object_or_404(Author, id=author_id)

    # Attempt to get author object from current user
    try:
        current_user = request.user.author
    except AttributeError:
        current_user = None

    if current_user is not None and current_user.id == post_author.id:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_friends_with(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_following(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "UNLISTED"]).order_by("-created_at")
    else:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC"]).order_by("-created_at")        

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_content = escape(p.content)
        html_content = render_markdown_if_needed(safe_content, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "raw_content": p.content,      
            "rendered_content": html_content,
            "content_type": p.content_type,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })

    return render(request, "social_distribution/profile.html", {
        "author": post_author,
        "posts": rendered_posts
    })

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if not request.user.is_authenticated or request.user != author.user:
        return HttpResponseForbidden("You are not allowed to edit this profile.")
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)
        if "profile_image" in request.FILES:
            file = request.FILES["profile_image"]
            encoded = base64.b64encode(file.read()).decode('utf-8')
            author.profile_image = encoded 
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        if form.is_valid():
            user = form.save()
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
            else:
                Author.objects.create(user=user, username=user.username, is_approved=False)
                messages.success(request, "Your account has been created and is pending admin approval.")
                return redirect("login")
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})


@user_passes_test(lambda u: u.is_superuser)  # Restrict to superusers (admins)
def admin_approval(request):
    pending_authors = Author.objects.filter(is_approved=False)
    return render(request, "social_distribution/admin_approval.html", {"pending_authors": pending_authors})

@user_passes_test(lambda u: u.is_superuser)
def approve_author(request, author_id):
    author = get_object_or_404(Author, id=author_id)
    author.is_approved = True
    author.save()
    messages.success(request, f"{author.username} has been approved.")
    return redirect("admin_approval")

@user_passes_test(lambda u: u.is_superuser)
def reject_author(request, author_id):
    author = get_object_or_404(Author, id=author_id)
    author.delete()  # Or deactivate the user instead of deleting
    messages.success(request, f"{author.username} has been rejected.")
    return redirect("admin_approval")

def pending_approval(request):
    return render(request, "social_distribution/pending_approval.html")

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            try:
                author = Author.objects.get(user=user)
                if not author.is_approved:
                    return redirect("pending_approval")
            except Author.DoesNotExist:
                messages.error(request, "Author profile not found.")
                return redirect("login")
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

def view_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    post_author = get_object_or_404(Author, id=author_id)
    serialized_post = PostSerializer(post).data
    safe_content = escape(post.content)
    html_content = render_markdown_if_needed(safe_content, post.content_type)
    post_comments = serialized_post["comments"]["src"]
    comments = []
    for comment in post_comments:
        comment["id"] = comment["id"].split("/")[-1]
        comments.append(comment)

    # Convert the post ot a new list with rendered text if needed
    rendered_post = {
        "id": post.id,
        "author": post.author,
        "raw_content": post.content,      
        "rendered_content": html_content,
        "content_type": post.content_type,
        "visibility": post.visibility,
        "created_at": post.created_at,
        "comments": comments,
        "likes": serialized_post["likes"],
    }

    # Attempt to get author object from current user
    try:
        current_user = request.user.author

    # If current user is not signed in
    except AttributeError:
        current_user = request.user
        if post.visibility == "FRIENDS":
            request.session["homepage_alert_message"] = "403 Error: Access denied due to not being signed-in"
            return redirect("index")
        
    # If current user is signed in, check access
    else:
        if post.visibility == "FRIENDS" and not (current_user == post_author or post_author.is_friends_with(current_user)):
            request.session["homepage_alert_message"] = "403 Error: Access denied due to not being friends with post's author"
            return redirect("index")
    return render(request, "social_distribution/view_post.html", {"post": rendered_post, "current_user": current_user})

def render_markdown_if_needed(text, content_type):
    """
    If content_type is 'text/markdown', convert 'text' to HTML using commonmark.
    Otherwise, return the text as-is (plain text).
    """
    if content_type == "text/markdown":
        return commonmark.commonmark(text or "")
    return text or "" 

def admin_controls(request):
    if not request.user.is_superuser:
        return redirect("index")

    node_info = NodeInfo.objects.first()
    if node_info:
        username = node_info.username
    else:
        username = ""
    
    return render(request, "social_distribution/admin_controls.html", {"nodes": RemoteNode.objects.all(), "username": username})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def edit_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to edit this post.")
    if request.method == "GET":
        return render(request, "social_distribution/edit_post.html", {"post": post})
    data = request.POST.copy()
    if post.content_type in ["image/png;base64", "image/jpeg;base64", "application/base64"] and "media_file" not in request.FILES:
        data.pop("content", None)
        return redirect("profile", author_id=author_id)
    serializer = PostSerializer(post, data=data, partial=True)
    if serializer.is_valid():
        media_file = request.FILES.get("media_file", None)
        if media_file:
            encoded_file = base64.b64encode(media_file.read()).decode("utf-8").strip()
            serializer.validated_data["content"] = encoded_file #type:ignore
            if media_file.content_type in ["image/png", "image/jpeg"]: 
                serializer.validated_data["content_type"] = f"{media_file.content_type};base64" #type:ignore
            else:
                serializer.validated_data["content_type"] = "application/base64" #type:ignore
        serializer.save()

        # Send updated posts to followers
        author = get_object_or_404(Author, id=author_id)
        send_post_to_remote(request, author, post)

        return redirect("profile", author_id=author_id)
    else:
        return render(request, "social_distribution/edit_post.html", {"post": post, "serializer": serializer})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def delete_post_local(request, author_id, post_id):
    """
    Local view to delete a post via an HTML confirmation page.
    GET: Render delete_post.html to confirm deletion, passing rendered_text.
    POST: Instead of deleting the post, mark its visibility as "DELETED" and redirect to the profile page.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to delete this post.")
    
    if request.method == "GET":
       safe_content = escape(post.content)
       rendered_text = render_markdown_if_needed(safe_content, post.content_type)
       return render(request, "social_distribution/delete_post.html", {"post": post, "rendered_text": rendered_text, "author": post.author})
    
    post.visibility = "DELETED"

    # Send updated posts to followers
    author = get_object_or_404(Author, id=author_id)
    send_post_to_remote(request, author, post)

    post.save()
    return redirect("profile", author_id=author_id)

# --- API Endpoints ---

@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def set_node_info(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        node_info = NodeInfo.objects.first()
        if node_info:
            node_info.username = request.POST["username"]
            node_info.password = request.POST["password"]
            node_info.host = settings.BASE_URL
            node_info.save()
            return Response("Node info updated", status=200)
        else:
            NodeInfo.objects.create(
                host=settings.BASE_URL,
                username=request.POST["username"],
                password=request.POST["password"]
            )
            return Response("Node info created", status=201)
        
    return Response("GET request not allowed", status=405)

@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def add_remote_node(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        node = RemoteNode.objects.filter(host=request.POST["host"]).first()
        username = request.POST["username"]
        password = request.POST["password"]

        if node:
            node.outgoing = True
            node.username = username
            node.password = password
            node.save()
            return Response("Node updated", status=200)
        else:
            RemoteNode.objects.create(
                host=request.POST["host"],
                outgoing=True,
                incoming=False,
                username=username,
                password=password
            )
            return Response("Node added", status=201)
    
    return Response("GET request not allowed", status=405)

@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def connect_node(request):
    if request.method == "POST":
        local_node = NodeInfo.objects.first()
        if not local_node:
            return Response("Local node not found", status=404)

        if request.META.get("HTTP_ORIGIN") == local_node.host:
            return Response("Forbidden", status=403)
        
        username = request.POST["username"]
        password = request.POST["password"]

        if local_node.username == username and local_node.password == password:
            remote_node = RemoteNode.objects.filter(host=request.META.get("HTTP_ORIGIN")).first()
            if remote_node:
                remote_node.incoming = True
                remote_node.save()
                return Response("Connected", status=200)
            else:
                RemoteNode.objects.create(
                    host=request.META.get("HTTP_ORIGIN"),
                    outgoing=False,
                    incoming=True
                )
                return Response("Connected", status=201)
        return Response("Unauthorized", status=401)
            
@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def remove_connection(request):
    if not request.user.is_superuser:
        return Response("Forbidden", status=403)
    
    if request.method == "POST":
        remote_node = RemoteNode.objects.filter(host=request.POST["host"]).first()
        if remote_node:
            remote_node.outgoing = False
            remote_node.save()
            return Response("Outgoing connection removed", status=200)
        return Response("Connection not found", status=404)

'''
@api_view(["GET"])
def get_authors(request):
    API: returns all authors in local node
    
    page_num = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    authors_qs = Author.objects.all().order_by("id")
    paginator = Paginator(authors_qs, size)
    page_obj = paginator.get_page(page_num)

    serializer = AuthorSerializer(page_obj, many=True)
    return Response({
        "type": "authors",
        "authors": serializer.data  
    })
'''

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_authors(request):
    """
    API: returns all authors on this local node
    """
    page_num = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    authors_qs = Author.objects.filter(host=settings.BASE_URL).order_by("id")
    paginator = Paginator(authors_qs, size)
    page_obj = paginator.get_page(page_num)

    serializer = AuthorSerializer(page_obj, many=True)
    return Response({
        "type": "authors",
        "authors": serializer.data
    })

@api_view(["GET", "PUT"])
@rate_limit(max_requests=1000, time_window=60)
def author_details(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        serializer = AuthorSerializer(author)
        return Response(serializer.data)
    
    if request.method == "PUT":
        if not request.user.is_authenticated or request.user.author != author:
            return Response({"detail": "Forbidden"}, status=403)

        serializer = AuthorSerializer(author, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)
    
@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def fqid_author_details(request, author_fqid):
    '''
    API: returns specific author detaisl using fqid.
    works for both local and remote (percent encoded path)
    '''
    decoded_fqid = unquote(author_fqid)
    author = get_object_or_404(Author, fqid=decoded_fqid)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)

@require_POST
def send_follow_request(request, author_id):
    # View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')
    current_author = request.user.author

    try:
        target_author = Author.objects.get(id=author_id)
    except Author.DoesNotExist:
        target_author = get_object_or_404(Author, fqid=author_id)

    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)
    
    if target_author.host != settings.BASE_URL:
        follow_request_data = {
            "type": "follow",
            "summary": f"{current_author.display_name} wants to follow {target_author.display_name}",
            "actor": AuthorSerializer(current_author).data,
        }

        try:
            remote_node = RemoteNode.objects.filter(host=target_author.host).first()
            if not remote_node:
                messages.error(request, "Remote node not found.")
                return redirect('profile', author_id=target_author.id)
            
            remote_inbox_url = f"{target_author.fqid}/inbox/"
            if remote_node.username and remote_node.password:
                response = requests.post(remote_inbox_url, json=follow_request_data, timeout=10, auth=(remote_node.username, remote_node.password))
            else:
                messages.error(request, "Remote node credentials are missing.")
                return redirect('profile', author_id=target_author.id)
            
            if response.status_code in [200, 201]:
                current_author.following.add(target_author)
                messages.success(request, f"Follow request sent to remote author {target_author.display_name}.")
            else:
                messages.error(request, f"Failed to send follow request to remote author: {response.text}")
        except Exception as e:
            messages.error(request, f"Error sending follow request to remote author: {str(e)}")
        return redirect('profile', author_id=target_author.id)
    else:
        FollowRequest.objects.create(sender=current_author, receiver=target_author)
        current_author.following.add(target_author)
        messages.success(request, f"Follow request sent to {target_author.display_name}.")
        return redirect('profile', author_id=target_author.id)
        
    
def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.filter(host=settings.BASE_URL, is_approved=True)
    authors = list(authors)
    
    for author in authors:
        author.page = f"/authors/{author.id}/"

    remote_nodes = RemoteNode.objects.filter(incoming=True, outgoing=True).exclude(host=settings.BASE_URL)
    for node in remote_nodes:
        if not node.username or not node.password:
            continue

        response = requests.get(f"{node.host}/api/authors/")
        if response.status_code == 200:
            remote_authors = response.json()["authors"]
            for remote_author in remote_authors:
                remote_author["host"] = node.host
                remote_author["fqid"] = remote_author["id"]
                remote_author["display_name"] = remote_author["displayName"]
                remote_author["username"] = remote_author["displayName"]

                remote_author_obj, _  = Author.objects.get_or_create(
                fqid=remote_author["fqid"],
                defaults={
                    "username": remote_author["displayName"],
                    "display_name": remote_author["displayName"],
                    "host": node.host,
                    "is_approved": False,
                    "user": None,  # no associated Django user
                    "profile_image": remote_author["profileImage"]
                }
                )  
                if remote_author_obj not in authors:
                    authors.append(remote_author_obj)

    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')
    
    notifications = []
    
    # Notifications for likes on posts
    post_like_qs = PostLike.objects.filter(object__author=current_author)
    for like in post_like_qs:
        notifications.append({
            "type": "like",
            "author": {
                "display_name": like.author.display_name,
                "username": like.author.username  # Include username explicitly
            },
            "published": like.published,
            "post_url": f"{like.object.author.host}/authors/{like.object.author.id}/posts/{like.object.id}/view/"
        })
    
    # Notifications for likes on comments on posts owned by the current user.
    comment_like_qs = CommentLike.objects.filter(object__post__author=current_author)
    for like in comment_like_qs:
        notifications.append({
            "type": "like_comment",
            "author": {
                "display_name": like.author.display_name,
                "username": like.author.username  # Include username explicitly
            },
            "published": like.published,
            "liked_comment": like.object.comment,
            "post_url": f"{like.object.post.author.host}/authors/{like.object.post.author.id}/posts/{like.object.post.id}/view/"
        })
    
    # Notifications for new comments on posts owned by the current user.
    comment_qs = Comment.objects.filter(post__author=current_author).exclude(author=current_author)
    for comment in comment_qs:
        notifications.append({
            "type": "comment",
            "author": {
                "display_name": comment.author.display_name,
                "username": comment.author.username  # Include username explicitly
            },
            "comment": comment.comment,
            "published": comment.published,
            "post_url": f"{comment.post.author.host}/authors/{comment.post.author.id}/posts/{comment.post.id}/view/"
        })
    
    following_notifications = []
    # Limit to the 5 latest posts by followed authors
    following_posts = Post.objects.filter(author__in=current_author.following.all()).exclude(author=current_author).order_by("-created_at")[:5]
    for post in following_posts:
        following_notifications.append({
            "type": "following_post",
            "author": {
                "display_name": post.author.display_name,
                "username": post.author.username  # Include username explicitly
            },
            "published": post.created_at,
            "post_url": f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/view/"
        })
    
    # Sort notifications by published date descending (latest first)
    notifications.sort(key=lambda n: n["published"], reverse=True)
    
    return render(request, "social_distribution/follow_requests.html", {
        "follow_requests": follow_requests,
        "like_notifications": notifications,
        "following_notifications": following_notifications  
    })

@require_POST
def approve_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'ACCEPTED'
    follow_request.save()
    follow_request.sender.following.add(receiver)
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors') # You can also redirect to another page if preferred.

@require_POST
def deny_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')

def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    current_author.following.remove(target_author)
    from .models import FeedBlock  
    FeedBlock.objects.get_or_create(blocker=current_author, blocked_author=target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name} and blocked their posts from your feed.")
    return redirect('profile', author_id=target_author.id)

def view_followers(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your followers.")
        return redirect('login')
    current_author = request.user.author
    followers = Author.objects.filter(following=current_author)
    return render(request, "social_distribution/followers.html", {"followers": followers})

# View to display authors that the current user follows
def view_following(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view who you're following.")
        return redirect('login')
    current_author = request.user.author  # Current userâ€™s Author profile
    following = current_author.following.all()
    return render(request, "social_distribution/following.html", {"following": following})

def view_friends(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your friends.")
        return redirect('login')
    current_author = request.user.author
    following = set(current_author.following.all())
    followers = set(Author.objects.filter(following=current_author))
    friends = following.intersection(followers)
    return render(request, "social_distribution/friends.html", {"friends": friends})

@api_view(['GET', 'DELETE', 'PUT'])
@rate_limit(max_requests=1000, time_window=60)
def posts_detail(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    Friends-only posts: must be authenticated and must be a friend.
    DELETE [local] remove a local posts: must be authenticated locally as the author
    PUT [local] update a post
    local posts: must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    author = post.author

    if request.method == "GET":
        # If post is marked DELETED, don't allow retrieval.
        if post.visibility == "DELETED":
            return Response({"detail": "Post not found."}, status=403)
        
        # For FRIENDS-only posts, enforce friendship check.
        if post.visibility == "FRIENDS":
            if not request.user.is_authenticated:
                return Response({"detail": "Authentication required."}, status=403)
            try:
                requesting_author = request.user.author
            except Author.DoesNotExist:
                return Response({"detail": "Authentication required."}, status=403)
            # Must be mutual friends.
            if requesting_author != author:
                 if (requesting_author not in author.following.all() or author not in requesting_author.following.all()):
                     return Response({"detail": "You are not friends with the author."}, status=403)
        serializer = PostSerializer(post)
        return Response(serializer.data)
    
    elif request.method == "DELETE":
        # Only the author can delete their post.
        if author.user != request.user:
            return Response(status=403)
        post.visibility = "DELETED"
        post.save()
        return Response(status=204)
    
    elif request.method == "PUT":
        # Only the author can update their post.
        if author.user != request.user:
            return Response(status=403)
        serializer = PostSerializer(post, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

@api_view(['GET'])
@rate_limit(max_requests=1000, time_window=60)
def get_post_by_fqid(request, post_fqid):
    """
    GET [remote] get the public post whose URL is POST_FQID
    Friends-only posts: must be authenticated and must be a friend.
    """
    decoded_fqid = unquote(post_fqid)
    post = get_object_or_404(Post, fqid=decoded_fqid)
    author = post.author

    # If post is marked DELETED, don't allow retrieval.
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)
    
    # For FRIENDS-only posts, enforce friendship check.
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)
        # Check mutual friendship
        if (requesting_author not in author.following.all() or
                author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET',"POST"])
@rate_limit(max_requests=1000, time_window=60)
def author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)

    if request.method == "GET":
        posts = Post.objects.filter(author=author).exclude(visibility="DELETED")
        if not request.user.is_authenticated:
            # Not logged in: show only public posts.
            posts = posts.filter(visibility='PUBLIC')
        elif request.user.author == author:
            # Viewing your own profile: show all posts.
            pass  
        else:
            current_author = request.user.author
            if author in current_author.following.all():
                # Check if current_author and author are mutual followers (i.e. friends).
                if current_author in author.following.all() and author in current_author.following.all():
                    # They are friends: allow public, unlisted, and friends-only posts.
                    posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED', 'FRIENDS'])
                else:
                    # One-way following: show public and unlisted posts.
                    posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED'])
            else:
                # Not mutual friends: show only public posts.
                posts = posts.filter(visibility='PUBLIC')

        page_number = int(request.GET.get("page", 1))
        size = int(request.GET.get("size", 10))
        paginator = Paginator(posts, size)
        page_obj = paginator.get_page(page_number)
        serializer = PostSerializer(page_obj, many=True)
        result = {
            "type": "posts",
            "page_number": page_number,
            "size": size,
            "count": paginator.count,
            "src": serializer.data,
        }
        return Response(result)
    
    elif request.method == "POST":
        author = get_object_or_404(Author, id=author_id)
        if author.user != request.user:
            return Response(status=403)
        serializer = PostSerializer(data=request.data, context={'author': author})
        if serializer.is_valid():
            serializer.save(author=author)
            return Response(serializer.data)
        return Response(serializer.errors, status=400)
           
def send_post_to_remote(request, author, post):
    for target_author in Author.objects.filter(following=author).exclude(host=settings.BASE_URL):
        try:
            if post.visibility == "FRIENDS" and not author.is_friends_with(target_author):
                continue
            
            remote_node = RemoteNode.objects.filter(host=target_author.host).first()
            if not remote_node:
                messages.error(request, f"Remote node not found for {target_author.display_name}.")
                continue
            if not remote_node.username or not remote_node.password:
                messages.error(request, f"Remote node credentials are missing for {target_author.display_name}.")
                continue

            remote_inbox_url = f"{target_author.fqid}/inbox/"
            response = requests.post(remote_inbox_url, json=PostSerializer(post).data, timeout=10, auth=(remote_node.username, remote_node.password))
            if response.status_code in [200, 201]:
                messages.success(request, f"Post sent to remote follower {target_author.display_name}.")
            else:
                messages.error(request, f"Failed to send post to remote follower: {response.text}")
        except Exception as e:
            messages.error(request, f"Error sending post to remote follower: {str(e)}")

@api_view(['POST'])
@permission_classes([IsAuthenticated])
@rate_limit(max_requests=1000, time_window=60)
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    
    
    content = request.data.get("content", "")
    media_file = request.FILES.get("media_file", None)

    if media_file and content.strip():
        error_message = "You cannot combine text and media in a single post. Please either enter text or upload media."
        return render(
            request,
            "social_distribution/create_post.html",
            {"errors": {"non_field_errors": [error_message]}}
        )
    
    visibility = request.data.get("visibility", "PUBLIC")
    content_type = request.data.get("content_type", "text/plain")
    has_file = False
    if media_file:
        has_file = True
        encoded_file = base64.b64encode(media_file.read()).decode("utf-8")
        encoded_file = encoded_file.strip()
        content = encoded_file
        if media_file.content_type in ["image/png", "image/jpeg"]:
            content_type = f"{media_file.content_type};base64"
        else:
            content_type = "application/base64"
        post_data = {
        "content_type": content_type,
        "content": content,
        "visibility": visibility
        }
        serializer = PostSerializer(data=post_data, context={"has_file": has_file})
    else:
        serializer = PostSerializer(data=request.data, context={"has_file": has_file})

    if serializer.is_valid():
        post = serializer.save(author=author)

        # Send post to followers
        send_post_to_remote(request, author, post)

        return redirect("profile", author_id=author.id)
    else:
        return render(request, "social_distribution/create_post.html", {
            "errors": serializer.errors
        })

@api_view(['GET'])
@rate_limit(max_requests=1000, time_window=60)
def get_post_image(request, author_id, post_id):
    """
    GET [local]: get the public post converted to binary as an image.
    Return 404 if not an image.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)

    # Check DELETED visibility
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)
    
    if post.content_type not in ["image/png;base64", "image/jpeg;base64", "application/base64"]:
        return Response({"detail": "Post does not have an image."}, status=404)
    
    # FRIENDS-only visibility logic
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)

        if (requesting_author not in post.author.following.all() or
                post.author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)
        
    try:
        binary_image_data = base64.b64decode(post.content)
    except Exception:
        return Response({"detail": "Error decoding image."}, status=400)

    # Dynamically detect image content type
    if post.content_type == "image/png;base64":
        mime_type = "image/png"
    elif post.content_type == "image/jpeg;base64":
        mime_type = "image/jpeg"
    elif post.content_type == "application/base64":
        mime_type = "application/octet-stream"
    else:
        mime_type = "application/octet-stream"

    return HttpResponse(binary_image_data, content_type=mime_type)

@api_view(['GET'])
@rate_limit(max_requests=1000, time_window=60)
def get_postimage_by_fqid(request, post_fqid):
    """
    GET [remote]: get the public post converted to binary as an image.
    Return 404 if not an image.
    """
    decoded_fqid = unquote(post_fqid)
    post = get_object_or_404(Post, fqid=decoded_fqid)

    # Check DELETED visibility
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)

    # Check if the post has an image
    if post.content_type not in ["image/png;base64", "image/jpeg;base64", "application/base64"]:
        return Response({"detail": "Post does not have an image."}, status=404)

    # FRIENDS-only visibility logic
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)

        if (requesting_author not in post.author.following.all() or
                post.author not in requesting_author.following.all()):
            return Response({"detail": "You are not friends with the author."}, status=403)
        
    try:
        binary_image_data = base64.b64decode(post.content)
    except Exception:
        return Response({"detail": "Error decoding image."}, status=400)

    # Dynamically detect image content type
    if post.content_type == "image/png;base64":
        mime_type = "image/png"
    elif post.content_type == "image/jpeg;base64":
        mime_type = "image/jpeg"
    elif post.content_type == "application/base64":
        mime_type = "application/octet-stream"
    else:
        mime_type = "application/octet-stream"

    return HttpResponse(binary_image_data, content_type=mime_type)

# ================= NEW: Followers and Follow Request API Endpoints =================

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_followers_api(request, author_id):
    """
    API: GET /api/authors/{author_id}/followers/
    Returns a JSON object with a list of authors who follow the given author.
    """
    author = get_object_or_404(Author, id=author_id)
    followers = Author.objects.filter(following=author)
    serializer = AuthorSerializer(followers, many=True)
    return Response({
        "type": "followers",
        "followers": serializer.data
    })

def is_remote(request):
    incoming_host = request.get_host()  # e.g., "[2605:fd00:4:1001:f816:3eff:fe2c:1382]"
    expected_host = urlparse(settings.BASE_URL).netloc  # strips 'http://' and gives same format
    return incoming_host != expected_host

def send_object(object_data, host, author_fqid):
    """
    Send object data to the remote node.
    """
    remote_node = RemoteNode.objects.filter(host=host).first()

    if not remote_node:
        return Response("No outgoing connection to remote node.", status=404)
    if not remote_node.username or not remote_node.password:
        return Response("Remote node credentials are missing.", status=401)
    
    # Send the object to the remote node's inbox
    
    inbox_url = f"{author_fqid}/inbox/"
    try:
        response = requests.post(inbox_url, json=object_data, timeout=10, auth=(remote_node.username, remote_node.password))
        return response
    except requests.exceptions.RequestException as e:
        return Response(f"Error sending object: {str(e)}", status=500)

@api_view(["POST"])
@authentication_classes([])
@rate_limit(max_requests=10, time_window=60)
@rate_limit(max_requests=1000, time_window=60)
def inbox(request, author_id):
    data = request.data
    receiver = get_object_or_404(Author, id=author_id)

    # === FOLLOW REQUEST === 
    if data.get("type") == "follow":
        actor_data = data.get("actor")
        if not actor_data:
            return Response({"detail": "Missing actor data."}, status=400)
        
        sender_fqid = actor_data.get("id")
        try:
            sender = Author.objects.get(fqid=sender_fqid)
        except Author.DoesNotExist:
            return Response({"detail": "Sender author not found in database."}, status=404)
        
        follow_req, created = FollowRequest.objects.get_or_create(sender=sender, receiver=receiver, defaults={"status": "PENDING"})

        if created:
            return Response({"detail": "Follow request created."}, status=201)
        else:
            return Response({"detail": "Follow request already exists."}, status=200)

    # Handles likes, comments from a local node
    elif not is_remote(request):

        # === POST LIKE ===
        if data.get("type") == "like":
            actor_data = data.get("actor")
            if not actor_data:
                return Response({"detail": "Missing actor data."}, status=400)
            sender_id = actor_data.get("id")
            try:
                sender_uuid = uuid.UUID(sender_id.split("/")[-1])
            except Exception:
                try:
                    sender_uuid = uuid.UUID(sender_id)
                except Exception:
                    return Response({"detail": "Invalid sender id."}, status=400)
            sender = get_object_or_404(Author, id=sender_uuid)
            published = data.get("published")
            post_id = data.get("post_id")
            if not post_id:
                return Response({"detail": "Missing post id."}, status=400)
            post_obj = get_object_or_404(Post, id=post_id)
            post_url = f"{post_obj.author.host}/authors/{post_obj.author.id}/posts/{post_obj.id}/"
            notification = {
                "type": "like_notification",
                "author": AuthorSerializer(sender).data,
                "published": published,
                "post_url": post_url
            }
            return Response({"detail": "Like notification received.", "notification": notification}, status=201)
        
        # === COMMENT ===
        # Expected payload to include: type, actor, post_id, comment, published
        elif data.get("type") == "comment":
            actor_data = data.get("actor")
            if not actor_data:
                return Response({"detail": "Missing actor data."}, status=400)
            sender_id = actor_data.get("id")
            try:
                sender_uuid = uuid.UUID(sender_id.split("/")[-1])
            except Exception:
                try:
                    sender_uuid = uuid.UUID(sender_id)
                except Exception:
                    return Response({"detail": "Invalid sender id."}, status=400)
            sender = get_object_or_404(Author, id=sender_uuid)
            post_id = data.get("post_id")
            if not post_id:
                return Response({"detail": "Missing post id."}, status=400)
            post_obj = get_object_or_404(Post, id=post_id)
            comment_text = data.get("comment")
            if not comment_text:
                return Response({"detail": "Missing comment text."}, status=400)
            published = data.get("published")
            post_url = f"{post_obj.author.host}/authors/{post_obj.author.id}/posts/{post_obj.id}/"
            notification = {
                "type": "comment_notification",
                "author": AuthorSerializer(sender).data,
                "comment": comment_text,
                "published": published,
                "post_url": post_url
            }
            return Response({"detail": "Comment notification received.", "notification": notification}, status=201)

        # === POST ===
        elif data.get("type") == "post":
            # Expect payload to include: title, id, page, description, contentType, content, author, comments, likes, published, visibility

            # Iterate through fields
            data_dict = {}
            for field in ["title", "id", "page", "description", "content_type", "content", "author", "comments", "likes", "published", "visibility"]:
                field_data = data.get(field)
                if not field_data:
                    return Response({"detail": "Missing %s" % field}, status=400)
                else:
                    data_dict[field] = field_data

            # Check post id
            try:
                data_dict["id"] = uuid.UUID(data_dict["id"].split("/"))
            except Exception:
                try:
                    data_dict["id"] = uuid.UUID(data_dict["id"])
                except Exception:
                    return Response({"detail": "Invalid post id."}, status=400)

            # Check author id
            try:
                data_dict["author"] = uuid.UUID(data_dict["author"].split("/"))
            except Exception:
                try:
                    data_dict["author"] = uuid.UUID(data_dict["author"])
                except Exception:
                    return Response({"detail": "Invalid author id."}, status=400)
                
            # Create new or get existing post object with id
            author = get_object_or_404(Author, id=data_dict["author"])
            post = Post.objects.get_or_create(
                author=author,
                text=data_dict["content"],
                created_at=data_dict["published"],
                content_type=data_dict["contentType"],
                visibility=data_dict["visibility"]
            )


        else:
            return Response({"detail": "Unsupported type for inbox."}, status=400)
        
    # Handles posts, likes and comments from a remote node
    elif is_remote(request): 
        # Authenticate with basic auth
        if "HTTP_AUTHORIZATION" not in request.META:
            return Response("Unauthorized", status=401)
        
        auth = request.META["HTTP_AUTHORIZATION"].split()

        if len(auth) != 2 or auth[0] != "Basic":
            return Response("Unauthorized", status=401)
        
        username, password = base64.b64decode(auth[1]).decode().split(":")

        node_info = NodeInfo.objects.all().first()
        if not node_info:
            return Response("Node info not found.", status=404)
        if node_info.username != username or node_info.password != password:
            return Response("Unauthorized", status=401)

        # === LIKE  ===
        if data.get("type") == "like":
            author_data = data.get("author")
            if not author_data:
                return Response({"detail": "Missing author data."}, status=400)
            
            sender_fqid = author_data.get("id")
            try:
                sender = Author.objects.get(fqid=sender_fqid)
            except Author.DoesNotExist:
                return Response({"detail": "Sender author not found in database."}, status=404)
            
            object_fqid = data.get("object")
            if not object_fqid:
                return Response({"detail": "Missing object field."}, status=400)
            
            like_fqid = data.get("id")
            published = data.get("published")
            parsed = urlparse(object_fqid)
            object_path = parsed.path

            # === COMMENT LIKE  ===
            if "/commented/" in object_path:
                try:
                    comment = Comment.objects.get(fqid=object_fqid)
                    Clike, created = CommentLike.objects.get_or_create(fqid=like_fqid,defaults={"object": comment,"author": sender,"published": parse_datetime(published)})
                    comment_data = CommentSerializer(comment).data
                    if not created:
                        Clike.delete()
                        # send new comment object to inbox
                        if comment.post.author.host != settings.BASE_URL:
                            # send the object to the remote node's inbox
                            send_object(comment_data, comment.post.author.host, comment.post.author.fqid)
                        return Response({"detail": "Comment like removed."}, status=200)
                    
                    if comment.post.author.host != settings.BASE_URL:
                        # send the object to the remote node's inbox
                        send_object(comment_data, comment.post.author.host, comment.post.author.fqid)
                    return Response({"detail": "Comment like stored."}, status=201)
                except Comment.DoesNotExist:
                    return Response({"detail": "Target comment not found."}, status=404)
                
            # === POST LIKE  ===
            elif "/posts/" in object_path:
                try:
                    post = Post.objects.get(fqid=object_fqid)
                    Plike, created = PostLike.objects.get_or_create(fqid=like_fqid,defaults={"object": post,"author": sender,"published": parse_datetime(published)})
                    if not created:
                        Plike.delete()
                        # send the updated post object to inboxes
                        send_post_to_remote(request, post.author, post)
                        return Response({"detail": "Post like removed."}, status=200)
                    post_url = f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/"
                    notification = { 
                        "type": "like_notification",
                        "author": AuthorSerializer(sender).data,
                        "published": published,
                        "post_url": post_url
                    }
                    return Response({"detail": "Post like stored.", "notification": notification}, status=201)
                except Post.DoesNotExist:
                    return Response({"detail": "Target post not found."}, status=404)
            else:
                return Response({"detail": "Unrecognized object type for like."}, status=400)
            
        # === COMMENT  === 
        elif data.get("type")=="comment":
            author_data = data.get("author")
            if not author_data:
                return Response({"detail": "Missing author data."}, status=400)

            sender_fqid = author_data.get("id")
            try:
                sender = Author.objects.get(fqid=sender_fqid)
            except Author.DoesNotExist:
                return Response({"detail": "Sender author not found in database."}, status=404)

            post_fqid = data.get("post")
            if not post_fqid:
                return Response({"detail": "Missing post field."}, status=400)

            comment_text = data.get("comment")
            content_type = data.get("contentType")
            published = data.get("published")
            comment_fqid = data.get("id")

            if not comment_text or not comment_fqid:
                return Response({"detail": "Missing comment text or comment fqid."}, status=400)

            try:
                post = Post.objects.get(fqid=post_fqid)
                comment, created = Comment.objects.get_or_create(
                    fqid=comment_fqid,
                    defaults={"post": post,"author": sender, "comment": comment_text, 'content_type': content_type, 'published': parse_datetime(published)})
            except Post.DoesNotExist:
                return Response({"detail": "Target post not found."}, status=404)
            
            # Handles embedded comment likes 
            likes_data = data.get("likes", {}).get("src", [])
            for like in likes_data:
                like_author_data = like.get("author")
                if not like_author_data:
                    continue
                liker_fqid = like_author_data.get("id")
                liker, _ = Author.objects.get_or_create(
                    fqid=liker_fqid,
                    defaults={
                        "host": like_author_data.get("host"),
                        "username": like_author_data.get("displayName"),
                        "display_name": like_author_data.get("displayName"),
                        "profile_image": like_author_data.get("profileImage"),
                        "is_approved": False,
                        "user": None,
                        })
                Clike = CommentLike.objects.get_or_create(fqid=like.get("id"),defaults={"object": comment,"author": liker,"published": parse_datetime(like.get("published"))})[0]

            post_url = f"{post.author.host}/authors/{post.author.id}/posts/{post.id}/" 
            notification = { 
                "type": "comment_notification",
                "author": AuthorSerializer(sender).data,
                "comment": comment.comment,
                "published": comment.published,
                "post_url": post_url
            }

            # Send the updated post object to inboxes
            send_post_to_remote(request, post.author, post)

            return Response({"detail": "Comment and embedded likes stored.", "notification": notification}, status=201)
        
        # === POST  ===
        elif data.get("type") == "post":
            post_fqid = data.get("id")
            author_data = data.get("author")
            if not post_fqid or not author_data:
                return Response({"detail": "Missing post ID or author data."}, status=400)

            # Gets the author of the remote post from the database if it exists, otherwise creates a new one
            author_fqid = author_data.get("id")
            post_author, _ = Author.objects.get_or_create(
                fqid=author_fqid,
                defaults={
                    "host": author_data.get("host"),
                    "username": author_data.get("displayName"),
                    "display_name": author_data.get("displayName"),
                    "profile_image": author_data.get("profileImage"),
                    "is_approved": False,
                    "user": None,
                })

            # Gets the remote post from the database if it exists, creates a new one otherwise
            post, created = Post.objects.get_or_create(
                fqid=post_fqid,
                defaults={
                    "author": post_author,
                    "content": data.get("content"),
                    "content_type": data.get("contentType"),
                    "visibility": data.get("visibility"),
                    "created_at": parse_datetime(data.get("published"))
                }
            )

            if not created:
                updated = False
                if post.content != data.get("content"):
                    post.content = data.get("content")
                    updated = True
                if post.content_type != data.get("contentType"):
                    post.content_type = data.get("contentType")
                    updated = True
                if post.visibility != data.get("visibility"):
                    post.visibility = data.get("visibility")
                    updated = True
                if post.created_at != parse_datetime(data.get("published")):
                    post.created_at = parse_datetime(data.get("published"))
                    updated = True

                if updated:
                    post.save()

            # Creates post like objects for a newly created remote post and updates post like objects for an existing remote post
            likes_data = data.get("likes", {}).get("src", [])
            incoming_like_fqids = set()

            for like in likes_data:
                like_fqid = like.get("id")
                incoming_like_fqids.add(like_fqid)
                like_author_data = like.get("author")
                like_author, _ = Author.objects.get_or_create(
                    fqid=like_author_data.get("id"),
                    defaults={
                        "host": like_author_data.get("host"),
                        "username": like_author_data.get("displayName"),
                        "display_name": like_author_data.get("displayName"),
                        "profile_image": like_author_data.get("profileImage"),
                        "is_approved": False,
                        "user": None,
                    })
                
                PostLike.objects.get_or_create(
                    fqid=like_fqid,
                    defaults={
                        "object": post,
                        "author": like_author,
                        "published": parse_datetime(like.get("published")),
                    })
                
            # Deletes any post likes associated with the remote post that are not in the incoming list 
            PostLike.objects.filter(object=post).exclude(fqid__in=incoming_like_fqids).delete()


            # Creates comment objects + comment likes for a newly created remote post and updates comment objects + comment likes for an existing remote post
            comments_data = data.get("comments", {}).get("src", [])
            incoming_comment_fqids = set()

            for comment_data in comments_data:
                comment_fqid = comment_data.get("id")
                incoming_comment_fqids.add(comment_fqid)
                comment_author_data = comment_data.get("author")
                comment_author, _ = Author.objects.get_or_create(
                    fqid=comment_author_data.get("id"),
                    defaults={
                        "host": comment_author_data.get("host"),
                        "username": comment_author_data.get("displayName"),
                        "display_name": comment_author_data.get("displayName"),
                        "profile_image": comment_author_data.get("profileImage"),
                        "is_approved": False,
                        "user": None,
                    })

                comment, _ = Comment.objects.get_or_create(
                    fqid=comment_fqid,
                    defaults={
                        "post": post,
                        "author": comment_author,
                        "comment": comment_data.get("comment"),
                        "content_type": comment_data.get("contentType"),
                        "published": parse_datetime(comment_data.get("published")),
                    })

                # Handle likes on the comment
                comment_likes = comment_data.get("likes", {}).get("src", [])
                comment_like_fqids = set()
                for like in comment_likes:
                    like_fqid = like.get("id")
                    comment_like_fqids.add(like_fqid)
                    like_author_data = like.get("author")
                    liker, _ = Author.objects.get_or_create(
                        fqid=like_author_data.get("id"),
                        defaults={
                            "host": like_author_data.get("host"),
                            "username": like_author_data.get("displayName"),
                            "display_name": like_author_data.get("displayName"),
                            "profile_image": like_author_data.get("profileImage"),
                            "is_approved": False,
                            "user": None,
                        })
                    
                    CommentLike.objects.get_or_create(
                        fqid=like_fqid,
                        defaults={
                            "object": comment,
                            "author": liker,
                            "published": parse_datetime(like.get("published")),
                        })

                # Delete any comment likes associated with the remote comment that are not in the incoming list
                CommentLike.objects.filter(object=comment).exclude(fqid__in=comment_like_fqids).delete()

            # Delete any comments associated with the remote post that are not in the incoming list
            Comment.objects.filter(post=post).exclude(fqid__in=incoming_comment_fqids).delete()
            return Response({"detail": "Post and associated objects processed."}, status=201 if created else 200)

        else:
            return Response({"detail": "Unsupported type for inbox."}, status=400)
    else:
        return Response({"detail": "Unsupported request."}, status=400)
            
    
@api_view(["GET", "PUT", "DELETE"])
@permission_classes([IsAuthenticated])
@rate_limit(max_requests=1000, time_window=60)
def modify_follower_api(request, author_id, foreign_author_encoded=None):
    """
    API endpoint to get, add, or remove a follower for the given author.
    
    GET:
      - If foreign_author_encoded is provided, check if that foreign author (after percentâ€decoding)
        is a follower of the author with id=author_id. (If yes, return the author object; if not, 404.)
      - If not provided, return a list of all followers.
    
    PUT:
      - Add the foreign author (provided via percent encoded string) as a follower of the author.
        (Authenticated user must be the owner of the profile.)
    
    DELETE:
      - Remove the foreign author as a follower of the author.
        (Authenticated user must be the owner.)
    """
    import urllib.parse
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        if foreign_author_encoded:
            foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
            try:
                foreign_author = Author.objects.get(fqid=foreign_author_id)
            except Author.DoesNotExist:
                return Response({"detail": "Foreign author not found."}, status=404)
            if author in foreign_author.following.all():
                return Response(AuthorSerializer(foreign_author).data, status=200)
            else:
                return Response({"detail": "Not a follower."}, status=404)
        else:
            followers = Author.objects.filter(following=author)
            data = {
                "type": "followers",
                "followers": AuthorSerializer(followers, many=True).data
            }
            return Response(data, status=200)
    elif request.method == "PUT":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(fqid=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        # To add the follower, we add the author to foreign_author.following.
        foreign_author.following.add(author)
        return Response({"detail": "Follower added."}, status=200)
    elif request.method == "DELETE":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(fqid=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        if author in foreign_author.following.all():
            foreign_author.following.remove(author)
            return Response({"detail": "Follower removed."}, status=200)
        else:
            return Response({"detail": "Foreign author is not a follower."}, status=404)


@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def api_send_follow_request(request, author_id):
    """
    API: send a follow request to the author with id=author_id.
    The authenticated user is taken as the actor.
    Expects a JSON payload containing at least "type": "follow".
    """
    if not request.user.is_authenticated:
        return Response({"detail": "Authentication required."}, status=403)
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    if current_author == target_author:
        return Response({"detail": "You cannot follow yourself."}, status=400)
    if FollowRequest.objects.filter(sender=current_author, receiver=target_author, status="PENDING").exists():
        return Response({"detail": "Follow request already sent."}, status=400)
    follow_req = FollowRequest.objects.create(sender=current_author, receiver=target_author)
    response_data = {
        "type": "follow",
        "summary": f"{current_author.display_name} wants to follow {target_author.display_name}",
        "actor": AuthorSerializer(current_author).data,
        "object": AuthorSerializer(target_author).data
    }
    return Response(response_data, status=201)

# ========================== COMMENTS ==========================
@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_comments(request, post_id, author_id=None):
    '''
    API: returns all comments for a post in the form of a "comments" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    # Get the relevant comments based on the post id and optional author id
    if author_id: # use author and post serial
        post_id = uuid.UUID(post_id)
        author_id = uuid.UUID(author_id)
        comments = Comment.objects.filter(post_id=post_id, post__author__id=author_id)
    else: # use post_fqid
        post_fqid = unquote(post_id)
        comments = Comment.objects.filter(post__fqid=post_fqid)
        author_id = Post.objects.get(fqid=post_fqid).author.id
        post_id = Post.objects.get(fqid=post_fqid).id

    paginator = Paginator(comments, size)
    page = paginator.get_page(page_number)
    serialized_comments = CommentSerializer(page, many=True).data
    host = settings.BASE_URL
    comments_data = {
        "type": "comments",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/comments",
        "page_number": page_number,
        "size": min(len(serialized_comments), size),
        "count": len(comments),
        "src": serialized_comments
    }
    return Response(comments_data)

@api_view(["GET", "POST"])
@rate_limit(max_requests=1000, time_window=60)
def commented(request, author_id):
    '''
    API: returns all comments made by an author, or allows an author to post a comment
    '''
    if request.method == "POST":
        # Add author id to the serializer data, make a copy of the data because it is immutable
        data = request.data.copy()
        if ("http" in author_id): # use author fqid
            author_id = unquote(author_id)
            author = get_object_or_404(Author, fqid=author_id)
        else: # use author serial
            author_id = uuid.UUID(author_id)
            author = get_object_or_404(Author, id=author_id)
        data["author"] = author.id

        serializer = CommentSerializer(data=data)
        if serializer.is_valid():
            serializer.save()

            # Send a notification to the inbox of the post author if the comment is on a remote post
            comment_data = serializer.data
            post_id = comment_data["post"]
            match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+)", post_id)
            if match:
                host = match.group(0)
            else:
                return Response({"detail": "Invalid post ID format."}, status=400)
            
            author_match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+/api/authors/[a-zA-Z0-9\[\]:.-]+)", post_id)
            if author_match:
                author_fqid = author_match.group(0)
            else:
                return Response({"detail": "Invalid author ID format."}, status=400)
            
            if host != settings.BASE_URL:
                remote_node = RemoteNode.objects.filter(host=host).first()
                if not remote_node:
                    return Response({"detail": "Remote node not found."}, status=404)
                
                if remote_node.username and remote_node.password:
                    response = requests.post(f"{author_fqid}/inbox/", json=comment_data, auth=(remote_node.username, remote_node.password))
                else:
                    return Response({"detail": "Remote node credentials not found."}, status=404)

                if response.status_code != 201:
                    Comment.objects.filter(fqid=comment_data["id"]).delete()
                    return Response({"detail": "Failed to send notification to post author."}, status=500)

            return Response(serializer.data, status=201)
        return Response(status=400, data=serializer.errors)
    else: # GET based on author fqid
        if ("http" in author_id):
            author_id = unquote(author_id)
            comments = Comment.objects.filter(author__fqid=author_id)
        else: # GET based on author serial
            author_id = uuid.UUID(author_id)
            comments = Comment.objects.filter(author_id=author_id)
        serializer = CommentSerializer(comments, many=True)
        return Response(serializer.data)

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_comment(request, comment_id, author_id=None, post_id=None):
    '''
    API: returns a specific comment
    '''

    # Get the comment based on the comment id
    if author_id:
        if post_id: # use author and post serial and remote comment fqid
            post_id = uuid.UUID(post_id)
            author_id = uuid.UUID(author_id)
            comment_id = unquote(comment_id)
            comment = get_object_or_404(Comment, fqid=comment_id, post__author__id=author_id, post_id=post_id)
        else: # use author and comment serial
            author_id = uuid.UUID(author_id)
            comment_id = uuid.UUID(comment_id)
            comment = get_object_or_404(Comment, id=comment_id, author_id=author_id)
    else: # use comment fqid
        comment_id = unquote(comment_id)
        comment = get_object_or_404(Comment, fqid=comment_id)
    
    # Return the comment
    serializer = CommentSerializer(comment)
    return Response(serializer.data)

# ========================== LIKES ==========================
@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_post_likes(request, post_id, author_id=None):
    '''
    API: returns all likes for a post
    '''

    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    if author_id: # use author and post serial
        post_id = uuid.UUID(post_id)
        author_id = uuid.UUID(author_id)
        likes = PostLike.objects.filter(object_id=post_id, object__author__id=author_id)
    else: # use post_fqid
        post_fqid = unquote(post_id)
        likes = PostLike.objects.filter(object__fqid=post_fqid)
        author_id = Post.objects.get(fqid=post_fqid).author.id
        post_id = Post.objects.get(fqid=post_fqid).id
    
    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_comment_likes(request, author_id, post_id, comment_id):
    '''
    API: returns all likes for a comment
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    comment_fqid = unquote(comment_id)
    post_id = uuid.UUID(post_id)
    author_id = uuid.UUID(author_id)
    comment = get_object_or_404(Comment, fqid=comment_fqid, post_id=post_id, post__author__id=author_id)
    likes = CommentLike.objects.filter(object_id=comment.id)
    comment_id = comment.id

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = CommentLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{comment.author.id}/comments/{comment_id}",
        "id": f"{host}/api/authors/{comment.author.id}/commented/{comment_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_author_liked(request, author_id):
    '''
    API: returns all likes made by an author
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))

    if ("http" in author_id):
        author_fqid = unquote(author_id)
        post_likes = PostLike.objects.filter(author__fqid=author_fqid)
        comment_likes = CommentLike.objects.filter(author__fqid=author_fqid)
        author_id = Author.objects.get(fqid=author_fqid).id
    else:    
        author_id = uuid.UUID(author_id)
        post_likes = PostLike.objects.filter(author_id=author_id)
        comment_likes = CommentLike.objects.filter(author_id=author_id)
    likes = list(post_likes) + list(comment_likes)

    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data
    host = settings.BASE_URL
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/likes",
        "id": f"{host}/api/authors/{author_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
@rate_limit(max_requests=1000, time_window=60)
def get_like(request, like_id, author_id=None):
    '''
    API: returns a specific like
    '''
    if author_id: # use author and like serial
        author_id = uuid.UUID(author_id)
        like_id = uuid.UUID(like_id)

        try:
            like = PostLike.objects.get(author_id=author_id, id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(author_id=author_id, id=like_id)
            post = False
    else: # use like fqid
        like_id = unquote(like_id)
        try:
            like = PostLike.objects.get(fqid=like_id)
            post = True
        except:
            like = CommentLike.objects.get(fqid=like_id)
            post = False
    if not like:
        return Response(status=404)
    if post:
        serializer = PostLikeSerializer(like)
    else:
        serializer = CommentLikeSerializer(like)
    return Response(serializer.data)

@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def like_post(request, author_id, post_id):
    '''
    API: allows an author to like a post
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = post_id
        serializer = PostLikeSerializer(data=data)
        if serializer.is_valid():
            if PostLike.objects.filter(author=author_id, object=post_id).exists():
                like_data = PostLikeSerializer(PostLike.objects.get(author=author_id, object=post_id)).data
                PostLike.objects.filter(author=author_id, object=post_id).delete()
                like_count = -1
            else:
                try:
                    serializer.save()
                    like_data = serializer.data
                    like_count = 1
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
                
            # Send a notification to the inbox of the post author if the like is on a remote post
            post_id = like_data["object"]
            match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+)", post_id)
            if match:
                host = match.group(0)
            else:
                return Response({"detail": "Invalid post ID format."}, status=400)
            
            author_match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+/api/authors/[a-zA-Z0-9\[\]:.-]+)", post_id)
            if author_match:
                author_fqid = author_match.group(0)
            else:
                return Response({"detail": "Invalid author ID format."}, status=400)
            
            if host != settings.BASE_URL:
                remote_node = RemoteNode.objects.filter(host=host).first()
                if not remote_node:
                    return Response({"detail": "Remote node not found."}, status=404)
                if remote_node.username and remote_node.password:
                    response = requests.post(f"{author_fqid}/inbox/", json=like_data, auth=(remote_node.username, remote_node.password))
                else:
                    return Response({"detail": "Remote node credentials not found."}, status=404)
                
                if response.status_code not in [201, 200]:
                    PostLike.objects.filter(fqid=like_data["id"]).delete()
                    return Response({"detail": "Failed to send notification to post author."}, status=500)


        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
        
    return Response({"like_count": like_count}, status=201)

@api_view(["POST"])
@rate_limit(max_requests=1000, time_window=60)
def like_comment(request, author_id, comment_id):
    '''
    API: allows an author to like a comment
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = comment_id
        serializer = CommentLikeSerializer(data=data)
        if serializer.is_valid():
            if CommentLike.objects.filter(author=author_id, object=comment_id).exists():
                like_data = CommentLikeSerializer(CommentLike.objects.get(author=author_id, object=comment_id)).data
                CommentLike.objects.filter(author=author_id, object=comment_id).delete()
                like_count = -1

            else:
                try:
                    serializer.save()
                    like_data = serializer.data
                    like_count = 1
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
                
            # Send a notification to the inbox of the comment author if the like is on a remote comment
            comment_id = like_data["object"]
            match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+)", comment_id)
            if match:
                host = match.group(0)
            else:
                return Response({"detail": "Invalid comment ID format."}, status=400)
            
            author_match = re.search(r"(http[s]?://[a-zA-Z0-9\[\]:.-]+/api/authors/[a-zA-Z0-9\[\]:.-]+)", comment_id)
            if author_match:
                author_fqid = author_match.group(0)
            else:
                return Response({"detail": "Invalid author ID format."}, status=400)
            
            if host != settings.BASE_URL:
                remote_node = RemoteNode.objects.filter(host=host).first()
                if not remote_node:
                    return Response({"detail": "Remote node not found."}, status=404)
                if remote_node.username and remote_node.password:
                    response = requests.post(f"{author_fqid}/inbox/", json=like_data, auth=(remote_node.username, remote_node.password))
                else:
                    return Response({"detail": "Remote node credentials not found."}, status=404)
                if response.status_code not in [201, 200]:
                    CommentLike.objects.filter(fqid=like_data["id"]).delete()
                    return Response({"detail": "Failed to send notification to comment author."}, status=500)

        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
    
    return Response({"like_count": like_count}, status=201)
