#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .models import Author, Post
from .serializers import AuthorSerializer
from django.conf import settings
from django.http import HttpResponse
from django.contrib.auth import login, logout, authenticate
# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User


# Create your views here.
def index(request):
    if request.user.is_authenticated:
        author = get_object_or_404(Author, username=request.user.username)
        followed_authors = author.following.all()
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: So in my project there are multiple users and when i go to the homepage, i should be able to see user's posts depending on whether i am logged in to the website. If i am logged in i should see friends, unlisted, and public posts, but if i am not logged i then i should just see public posts. here are my models (screenshot of my models). Please tell me how to write my index method in views.py in order to see the correst stream in homepage>
        posts = Post.objects.filter(author__in=followed_authors, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).exclude(visibility="DELETED").order_by("-created_at")
        public_posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        posts = (posts | public_posts).distinct().order_by("-created_at")
        #<END GENERATED></END>
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")

    return render(request, "social_distribution/index.html", {"posts": posts})

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author, visibility="PUBLIC").order_by("-created_at")
    return render(request, "social_distribution/profile.html", {"author": author, "posts": posts})

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)

        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        # https://www.pythontutorial.net/django-tutorial/django-registration/
        if form.is_valid():
            user = form.save()
            #<BEGIN GENERATED model='gpt-4' date=2025-02-17 promt: when i create a new author using api request, then a user is not linked to it so i have to register the user in order for the user to be able to login, but when i register, i get an error how do i fix?>
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
                #<END GENERATED></END>
            else:
                Author.objects.create(user=user, username=user.username)
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    local_authors = Author.objects.filter(host=settings.BASE_URL)
    serializer = AuthorSerializer(local_authors, many=True)
    return Response(serializer.data)

@api_view(["GET"])
def get_author(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author)
    return Response(serializer.data)


@api_view(["POST"])
def create_author(request):
    '''
    API: creates a new author 
    '''
    serializer = AuthorSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=201)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def update_author(request, author_id):
    '''
    API: updates an author's profile
    ''' 
    author = get_object_or_404(Author, id=author_id)
    serializer = AuthorSerializer(author, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(status=400, data=serializer.errors)

@api_view(["POST"])
def inbox(request, author_id):
    '''
    TODO: implement then inbox to handle a variety of API calls
    '''
    pass

@api_view(["GET"])
def get_comments(request, post_id, author_id=None):
    '''
    API: returns all comments for a post in the form of a "comments" object
    GET [local, remote]: the comments on the post {AUTHOR_SERIAL} {POST_SERIAL}
    GET [local, remote]: the comments on the post (that our server knows about) {POST_FQID}
    Body is a "comments" object
    '''
    pass

@api_view(["GET", "POST"])
def commented(request, author_id):
    '''
    API: returns all comments made by an author, or allows an author to post a comment
    GET [local, remote] get the list of comments author has made on: {AUTHOR_SERIAL}
        [local] any post
        [remote] public and unlisted posts
        paginated
    POST [local] if you post an object of "type":"comment", it will add your comment to the post whose ID is in the post field
        Then the node you posted it to is responsible for forwarding it to the correct inbox

    GET [local] get the list of comments author has made on any post (that local node knows about) {AUTHOR_FQID}
    body is list of "comment" objects
    '''
    pass

@api_view(["GET"])
def get_comment(request, comment_id, author_id=None, post_id=None):
    '''
    API: returns a specific comment
    GET [local, remote] get the comment {AUTHOR_SERIAL} {POST_SERIAL} {REMOTE_COMMENT_FQID}
    GET [local, remote] get this comment {AUTHOR_SERIAL} {COMMENT_SERIAL}
    GET [local] get this comment {COMMENT_FQID}
    body is a "comment" object
    '''
    pass

@api_view(["GET"])
def get_post_likes(request, post_id, author_id=None):
    '''
    API: returns all likes for a post
    GET [local, remote] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL {AUTHOR_SERIAL} {POST_SERIAL}
    GET [local] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL {POST_FQID}
    body is a "likes" object
    '''
    pass

@api_view(["GET"])
def get_comment_likes(request, like_id, comment_id):
    '''
    API: returns all likes for a comment
    GET [local, remote] a list of likes from other authors on AUTHOR_SERIAL's post POST_SERIAL comment COMMENT_FQID
    body is a "likes" object
    '''
    pass

@api_view(["GET"])
def get_author_liked(request, author_id):
    '''
    API: returns all likes made by an author
    GET [local, remote] a list of likes by AUTHOR_SERIAL {AUTHOR_SERIAL}
    GET [local] a list of likes by AUTHOR_FQID {AUTHOR_FQID}
    body is a "likes" object
    '''
    pass

@api_view(["GET"])
def get_like(request, like_id, author_id=None):
    '''
    API: returns a specific like
    GET [local, remote] a single like {AUTHOR_SERIAL} {LIKE_SERIAL}
    GET [local] a single like {LIKE_FQID}
    body is a "like" object
    '''
    pass