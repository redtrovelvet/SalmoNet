#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model='gpt-4' date=2025-02-17>
#and followed by #<END GENERATED></END>.

from django.shortcuts import render, get_object_or_404, redirect
from rest_framework.response import Response
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from .models import Author, Post, FollowRequest, Comment, CommentLike, PostLike
from .serializers import AuthorSerializer, PostSerializer, CommentSerializer, CommentLikeSerializer, PostLikeSerializer
from django.conf import settings
from django.contrib.auth import login, logout, authenticate
from django.http import HttpResponseForbidden, HttpResponse, JsonResponse
from django.utils.html import escape
from django.urls import reverse

# https://www.pythontutorial.net/django-tutorial/django-registration/
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.contrib import messages  
from django.views.decorators.http import require_POST, require_http_methods
from django.core.paginator import Paginator
import commonmark, uuid
from urllib.parse import unquote

# Create your views here.
def index(request):
    if request.user.is_authenticated:
        current_author = get_object_or_404(Author, username=request.user.username)
        # Get posts from authors that current_author follows
        posts = Post.objects.filter(author=current_author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
        for author in current_author.following.all():
            if current_author in author.following.all():
                # Mutual follow (friends): include PUBLIC, UNLISTED, and FRIENDS posts
                author_posts = Post.objects.filter(author=author, visibility__in=["PUBLIC", "UNLISTED", "FRIENDS"])
            else:
                # Not mutual: only include PUBLIC and UNLISTED posts
                author_posts = Post.objects.filter(author=author).exclude(visibility__in=["FRIENDS", "DELETED"])
            posts |= author_posts

        # Also include public posts from all other authors (to widen the feed)
        public_posts = Post.objects.filter(visibility="PUBLIC")
        posts = (posts | public_posts).distinct().order_by("-created_at")
    else:
        posts = Post.objects.filter(visibility="PUBLIC").exclude(visibility="DELETED").order_by("-created_at")
        current_author = None

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    # Convert posts to a new list with rendered text if needed
    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_text = escape(p.text)
        html_text = render_markdown_if_needed(safe_text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })
    context = {"posts": rendered_posts, "author": current_author}

    # Check for alert message
    if "homepage_alert_message" in request.session:
        alert_message = request.session.pop("homepage_alert_message")
        context["alert_message"] = alert_message

    return render(request, "social_distribution/index.html", context)

def profile(request, author_id):
    '''
    renders the profile page for an author
    '''
    post_author = get_object_or_404(Author, id=author_id)

    # Attempt to get author object from current user
    try:
        current_user = request.user.author
    except AttributeError:
        current_user = None

    if current_user is not None and current_user.id == post_author.id:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS", "UNLISTED"]).order_by("-created_at")
    elif current_user is not None and post_author.is_friends_with(current_user):
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC", "FRIENDS"]).order_by("-created_at")
    else:
        posts = Post.objects.filter(author=post_author, visibility__in=["PUBLIC"]).order_by("-created_at")        

    # Serialize posts
    serialized_posts = PostSerializer(posts, many=True).data.copy()

    rendered_posts = []
    for i in range(len(serialized_posts)):
        p = posts[i]
        sp = serialized_posts[i]
        safe_text = escape(p.text)
        html_text = render_markdown_if_needed(safe_text, p.content_type)
        post_comments = sp["comments"]["src"]
        comments = []
        for comment in post_comments:
            comment["id"] = comment["id"].split("/")[-1]
            comments.append(comment)

        rendered_posts.append({
            "id": p.id,
            "author": p.author,
            "text": html_text,
            "image": p.image,
            "video": p.video,
            "visibility": p.visibility,
            "created_at": p.created_at,
            "comments": comments,
            "likes": sp["likes"],
        })

    return render(request, "social_distribution/profile.html", {
        "author": post_author,
        "posts": rendered_posts
    })

def edit_profile(request, author_id):
    '''
    To allow authors to edit their profile information like display name, github, and profile image
    '''
    author = get_object_or_404(Author, id=author_id)
    if not request.user.is_authenticated or request.user != author.user:
        return HttpResponseForbidden("You are not allowed to edit this profile.")
    if request.method == "POST":
        author.display_name = request.POST.get("display_name", author.display_name)
        author.github = request.POST.get("github", author.github)
        if "profile_image" in request.FILES:
            author.profile_image = request.FILES["profile_image"]
        author.save()
        return redirect("profile", author_id=author.id)
    return render(request, "social_distribution/edit_profile.html", {"author": author})

def register(request):
    '''
    To handle registration of new users and will create an Auther profile
    '''
    if request.method == "POST":
        #<BEGIN GENERATED model='gpt-4' date=2025-02-17 prompt: i want to create registration form in django user UserCreationForm, but i dont want to create a new class to do so, can you help me create the registration form in my register method in views.py?>
        form = UserCreationForm(request.POST)
         #<END GENERATED></END>
        if form.is_valid():
            user = form.save()
            existing_authors = Author.objects.filter(username=user.username, user__isnull=True)
            if existing_authors.exists():
                author = existing_authors.first()
                author.user = user  # type: ignore
                author.save() # type: ignore
            else:
                Author.objects.create(user=user, username=user.username)
            login(request, user)
            return redirect("index")
    else:
        form = UserCreationForm()
    return render(request, "social_distribution/register.html", {"form": form})

def login_view(request):
    '''
    To handle user login
    '''
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect("index")
    else:
        form = AuthenticationForm()
    return render(request, "social_distribution/login.html", {"form": form})

def logout_view(request):
    '''
    Logs the author out and returns to homepage (index.html)
    '''
    logout(request)
    return redirect("index")

def view_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    post_author = get_object_or_404(Author, id=author_id)
    serialized_post = PostSerializer(post).data
    safe_text = escape(post.text)
    html_text = render_markdown_if_needed(safe_text, post.content_type)
    post_comments = serialized_post["comments"]["src"]
    comments = []
    for comment in post_comments:
        comment["id"] = comment["id"].split("/")[-1]
        comments.append(comment)

    # Convert the post ot a new list with rendered text if needed
    rendered_post = {
        "id": post.id,
        "author": post.author,
        "text": html_text,
        "image": post.image,
        "video": post.video,
        "visibility": post.visibility,
        "created_at": post.created_at,
        "comments": comments,
        "likes": serialized_post["likes"],
    }

    # Attempt to get author object from current user
    try:
        current_user = request.user.author

    # If current user is not signed in
    except AttributeError:
        current_user = request.user
        if post.visibility == "FRIENDS":
            request.session["homepage_alert_message"] = "Error: Access denied"
            return redirect("index")
        
    # If current user is signed in, check access
    else:
        if post.visibility == "FRIENDS" and not (current_user == post_author or post_author.is_friends_with(current_user)):
            request.session["homepage_alert_message"] = "Error: Access denied"
            return redirect("index")
    return render(request, "social_distribution/view_post.html", {"post": rendered_post, "current_user": current_user})

def render_markdown_if_needed(text, content_type):
    """
    If content_type is 'text/markdown', convert 'text' to HTML using commonmark.
    Otherwise, return the text as-is (plain text).
    """
    if content_type == "text/markdown":
        return commonmark.commonmark(text or "")
    return text or "" 

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def edit_post(request, author_id, post_id):
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to edit this post.")
    if request.method == "GET":
        return render(request, "social_distribution/edit_post.html", {"post": post})
    data = request.POST.copy()

    # If user checked "Remove Image", ensure data contains image as None.
    if "remove_image" in data:
        data["image"] = None
    else:
        # Only remove the key if no new file is uploaded.
        image_val = data.get("image", "")
        if image_val is None or (isinstance(image_val, str) and not image_val.strip()):
            # Only pop if the remove checkbox was NOT checked.
            data.pop("image", None)

    # Similarly for video.      
    if "remove_video" in data:
        data["video"] = None
    else:
        video_val = data.get("video", "")
        if video_val is None or (isinstance(video_val, str) and not video_val.strip()):
            data.pop("video", None)

    serializer = PostSerializer(post, data=data, partial=True)
    if serializer.is_valid():
        # If new files are uploaded, attach them.
        if "image" in request.FILES:
            serializer.validated_data["image"] = request.FILES["image"]  # type:ignore
        if "video" in request.FILES:
            serializer.validated_data["video"] = request.FILES["video"]  # type:ignore
        serializer.save()
        return redirect("profile", author_id=author_id)
    else:
        return render(request, "social_distribution/edit_post.html", {"post": post, "serializer": serializer})

@require_http_methods(["GET", "POST"])
@permission_classes([IsAuthenticated])
def delete_post_local(request, author_id, post_id):
    """
    Local view to delete a post via an HTML confirmation page.
    GET: Render delete_post.html to confirm deletion, passing rendered_text.
    POST: Instead of deleting the post, mark its visibility as "DELETED" and redirect to the profile page.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return HttpResponseForbidden("You are not allowed to delete this post.")
    
    if request.method == "GET":
        safe_text = escape(post.text)
        rendered_text = render_markdown_if_needed(safe_text, post.content_type)
        return render(request, "social_distribution/delete_post.html", {"post": post, "rendered_text": rendered_text, "author": post.author})
    
    post.visibility = "DELETED"
    post.save()
    return redirect("profile", author_id=author_id)

# --- API Endpoints ---

@api_view(["GET"])
def get_authors(request):
    '''
    API: returns all authors in local node
    '''
    page_num = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    authors_qs = Author.objects.all().order_by("id")
    paginator = Paginator(authors_qs, size)
    page_obj = paginator.get_page(page_num)

    serializer = AuthorSerializer(page_obj, many=True)
    return Response({
        "type": "authors",
        "authors": serializer.data  
    })

@api_view(["GET", "PUT"])
def author_details(request, author_id):
    '''
    API: returns specific author profiile
    '''
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        serializer = AuthorSerializer(author)
        return Response(serializer.data)
    
    if request.method == "PUT":
        if not request.user.is_authenticated or request.user.author != author:
            return Response({"detail": "Forbidden"}, status=403)

        serializer = AuthorSerializer(author, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

@require_POST
def send_follow_request(request, author_id):
    # View to send a follow request from current user to the target author
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to follow authors.")
        return redirect('login')
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    if current_author == target_author:
        messages.error(request, "You cannot follow yourself.")
        return redirect('profile', author_id=target_author.id)
    if current_author.sent_requests.filter(receiver=target_author, status='PENDING').exists():
        messages.info(request, "You already sent a follow request to this author.")
        return redirect('profile', author_id=target_author.id)
    FollowRequest.objects.create(sender=current_author, receiver=target_author)
    messages.success(request, f"Follow request sent to {target_author.display_name}.")
    return redirect('profile', author_id=target_author.id)

def all_authors(request):
    """
    Retrieve and display all authors.
    """
    authors = Author.objects.all()
    return render(request, "social_distribution/all_authors.html", {"authors": authors})

def view_follow_requests(request):
    """
    View incoming follow requests for the logged-in user.
    """
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view follow requests.")
        return redirect('login')
    current_author = request.user.author
    follow_requests = FollowRequest.objects.filter(receiver=current_author, status='PENDING')
    return render(request, "social_distribution/follow_requests.html", {"follow_requests": follow_requests})

@require_POST
def approve_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'ACCEPTED'
    follow_request.save()
    follow_request.sender.following.add(receiver)
    messages.success(request, f"You have approved {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors') # You can also redirect to another page if preferred.

@require_POST
def deny_follow_request(request, request_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to manage follow requests.")
        return redirect('login')
    receiver = request.user.author
    follow_request = get_object_or_404(FollowRequest, id=request_id, receiver=receiver, status='PENDING')
    follow_request.status = 'DENIED'
    follow_request.save()
    messages.info(request, f"You have denied {follow_request.sender.display_name}'s follow request.")
    return redirect('all_authors')

def unfollow_author(request, author_id):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to unfollow authors.")
        return redirect('login')
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    current_author.following.remove(target_author)
    from .models import FeedBlock  
    FeedBlock.objects.get_or_create(blocker=current_author, blocked_author=target_author)
    messages.success(request, f"You have unfollowed {target_author.display_name} and blocked their posts from your feed.")
    return redirect('profile', author_id=target_author.id)

def view_followers(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your followers.")
        return redirect('login')
    current_author = request.user.author
    followers = Author.objects.filter(following=current_author)
    return render(request, "social_distribution/followers.html", {"followers": followers})

# View to display authors that the current user follows
def view_following(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view who you're following.")
        return redirect('login')
    current_author = request.user.author  # Current user’s Author profile
    following = current_author.following.all()
    return render(request, "social_distribution/following.html", {"following": following})
    # ^^^ RENDER following.html with the list of following

def view_friends(request):
    if not request.user.is_authenticated:
        messages.error(request, "Please log in to view your friends.")
        return redirect('login')
    current_author = request.user.author
    following = set(current_author.following.all())
    followers = set(Author.objects.filter(following=current_author))
    friends = following.intersection(followers)
    return render(request, "social_distribution/friends.html", {"friends": friends})

@api_view(['GET'])
def get_post(request, author_id, post_id):
    """
    GET [local, remote] get the public post whose serial is POST_ID
    Friends-only posts: must be authenticated and must be a friend.
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)

    # no access to deleted post
    if post.visibility == "DELETED":
        return Response({"detail": "Post not found."}, status=403)
    
    author = post.author

    # If the post is friends-only, enforce friendship check
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        
        # Ensure the authenticated user is an author in your system
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "Authentication required."}, status=403)
        
        # Check if the requesting user is actually a friend of the post author
        if requesting_author not in author.following.all() or author not in requesting_author.following.all():
            return Response({"detail": "You are not friends with the author."}, status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_post(request, author_id, post_id):
    """
    DELETE [local] remove a local post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    post.visibility = "DELETED"
    post.save()
    return Response(status=204)

@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def update_post(request, author_id, post_id):
    """
    PUT [local] update a post
    must be authenticated locally as the author
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.author.user != request.user:
        return Response(status=403)
    serializer = PostSerializer(post, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=400)

@api_view(['GET'])
def get_post_by_fqid(request, post_fqid):
    """
    GET [local] get the public post whose URL is POST_FQID
    Friends-only posts: must be authenticated and must be a friend.
    """
    post = get_object_or_404(Post, id=post_fqid)
    author = post.author

    # If the post is friends-only, enforce friendship check
    if post.visibility == 'FRIENDS':
        if not request.user.is_authenticated:
            return Response({"detail": "Authentication required."}, status=403)
        
        # Ensure the authenticated user is an author in your system
        try:
            requesting_author = request.user.author
        except Author.DoesNotExist:
            return Response({"detail": "User is not an author."}, status=403)
        
        # Check if the requesting user is actually a friend of the post author
        if requesting_author not in author.following.all() or author not in requesting_author.following.all():
            return Response({"detail": "You are not friends with the author."}, status=403)
    serializer = PostSerializer(post)
    return Response(serializer.data)

@api_view(['GET'])
def get_author_posts(request, author_id):
    """
    GET [local, remote] get the recent posts from author AUTHOR_ID (paginated)
    Not authenticated: only public posts.
    Authenticated locally as author: all posts.
    Authenticated locally as follower of author: public + unlisted posts.
    Authenticated locally as friend of author: all posts.
    """
    author = get_object_or_404(Author, id=author_id)
    posts = Post.objects.filter(author=author).exclude(visibility="DELETED")

    if not request.user.is_authenticated:
        # Not logged in: show only public posts.
        posts = posts.filter(visibility='PUBLIC')
    elif request.user.author == author:
        # Viewing your own profile: show all posts.
        pass  
    else:
        current_author = request.user.author
        if author in current_author.following.all():
            # Check if current_author and author are mutual followers (i.e. friends).
            if current_author in author.following.all() and author in current_author.following.all():
                # They are friends: allow public, unlisted, and friends-only posts.
                posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED', 'FRIENDS'])
            else:
                # One-way following: show public and unlisted posts.
                posts = posts.filter(visibility__in=['PUBLIC', 'UNLISTED'])
        else:
            # Not mutual friends: show only public posts.
            posts = posts.filter(visibility='PUBLIC')
    serializer = PostSerializer(posts, many=True)
    return Response(serializer.data)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_post(request, author_id):
    """
    POST [local] create a new post but generate a new ID
    Authenticated locally as author
    """
    author = get_object_or_404(Author, id=author_id)
    if author.user != request.user:
        return Response(status=403)
    data = request.data
    serializer = PostSerializer(data=data, context={'author': author})
    if serializer.is_valid() and not (data.get("text") == "" and data.get("image") == "" and data.get("video") == ""):
        serializer.save(author=author)
        return redirect("profile", author_id=author.id)
    
    url = reverse("profile", kwargs={'author_id': author.id})
    return redirect(f"{url}?message=Error: Post must have text, image, or video.")

@api_view(['GET'])
def get_post_image(request, author_id, post_id):
    """
    GET [local, remote] get the public post converted to binary as an image
    return 404 if not an image
    """
    post = get_object_or_404(Post, id=post_id, author_id=author_id)
    if post.content_type not in ['image/png', 'image/jpeg']:
        return Response(status=404)
    if post.visibility == 'FRIENDS' and not request.user.is_authenticated:
        return Response(status=403)
    return Response(post.image.read(), content_type=post.content_type)

# ================= NEW: Followers and Follow Request API Endpoints =================

@api_view(["GET"])
def get_followers_api(request, author_id):
    """
    API: GET /api/authors/{author_id}/followers/
    Returns a JSON object with a list of authors who follow the given author.
    """
    author = get_object_or_404(Author, id=author_id)
    followers = Author.objects.filter(following=author)
    serializer = AuthorSerializer(followers, many=True)
    return Response({
        "type": "followers",
        "followers": serializer.data
    })

@api_view(["POST"])
def inbox(request, author_id):
    '''
    API: Inbox endpoint to receive various objects.
    If the payload has type "follow", create a follow request.
    '''
    data = request.data
    if data.get("type") == "follow":
        actor_data = data.get("actor")
        if not actor_data:
            return Response({"detail": "Missing actor data."}, status=400)
        sender_id = actor_data.get("id")
        receiver = get_object_or_404(Author, id=author_id)
        try:
            sender_uuid = uuid.UUID(sender_id.split("/")[-1])
        except Exception:
            try:
                sender_uuid = uuid.UUID(sender_id)
            except Exception:
                return Response({"detail": "Invalid sender id."}, status=400)
        sender = get_object_or_404(Author, id=sender_uuid)
        follow_req, created = FollowRequest.objects.get_or_create(sender=sender, receiver=receiver, defaults={"status": "PENDING"})
        if created:
            return Response({"detail": "Follow request created."}, status=201)
        else:
            return Response({"detail": "Follow request already exists."}, status=200)
    else:
        return Response({"detail": "Unsupported type for inbox."}, status=400)

# ========================== COMMENTS ==========================
@api_view(["GET"])
def get_comments(request, post_id, author_id=None):
    '''
    API: returns all comments for a post in the form of a "comments" object
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 5))

    # Get the relevant comments based on the post id and optional author id
    if author_id:
        comments = Comment.objects.filter(post_id=post_id)
    else:
        comments = Comment.objects.filter(post_id=post_id)
        author_id = Post.objects.get(id=post_id).author.id
    paginator = Paginator(comments, size)
    page = paginator.get_page(page_number)
    serialized_comments = CommentSerializer(page, many=True).data
    host = settings.BASE_URL
    comments_data = {
        "type": "comments",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/comments",
        "page_number": page_number,
        "size": min(len(serialized_comments), size),
        "count": len(comments),
        "src": serialized_comments
    }
    return Response(comments_data)

@api_view(["GET", "POST"])
def commented(request, author_id):
    '''
    API: returns all comments made by an author, or allows an author to post a comment
    '''
    if request.method == "POST":
        # Add author id to the serializer data, make a copy of the data because it is immutable
        data = request.data.copy()
        author = get_object_or_404(Author, id=author_id)
        data["author"] = author.id

        serializer = CommentSerializer(data=data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=201)
        return Response(status=400, data=serializer.errors)
    else:
        comments = Comment.objects.filter(author_id=author_id)
        serializer = CommentSerializer(comments, many=True)
        return Response(serializer.data)

@api_view(["GET"])
def get_comment(request, comment_id, author_id=None, post_id=None):
    '''
    API: returns a specific comment
    '''

    # Get the comment based on the comment id
    if author_id:
        if post_id:
            comment = get_object_or_404(Comment, id=comment_id)
        else:
            comment = get_object_or_404(Comment, id=comment_id)
    else:
        comment = get_object_or_404(Comment, id=comment_id)
    
    # Return the comment
    serializer = CommentSerializer(comment)
    return Response(serializer.data)

# ========================== LIKES ==========================
@api_view(["GET"])
def get_post_likes(request, post_id, author_id=None):
    '''
    API: returns all likes for a post
    '''

    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    if author_id:
        likes = PostLike.objects.filter(object=post_id)
    else:
        likes = PostLike.objects.filter(object=post_id)
        author_id = Post.objects.get(id=post_id).author.id
    
    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/posts/{post_id}",
        "id": f"{host}/api/authors/{author_id}/posts/{post_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_comment_likes(request, author_id, post_id, comment_id):
    '''
    API: returns all likes for a comment
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    likes = CommentLike.objects.filter(object=comment_id)

    # Paginate the likes
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = CommentLikeSerializer(page, many=True).data

    # Get the host for the page
    host = settings.BASE_URL

    # Create the likes object
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/comments/{comment_id}",
        "id": f"{host}/api/authors/{author_id}/commented/{comment_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_author_liked(request, author_id):
    '''
    API: returns all likes made by an author
    '''
    # Get optional query parameters for pagination
    page_number = int(request.GET.get("page", 1))
    size = int(request.GET.get("size", 50))
    post_likes = PostLike.objects.filter(author=author_id)
    comment_likes = CommentLike.objects.filter(author=author_id)
    likes = list(post_likes) + list(comment_likes)
    paginator = Paginator(likes, size)
    page = paginator.get_page(page_number)
    serialized_likes = PostLikeSerializer(page, many=True).data
    host = settings.BASE_URL
    likes_data = {
        "type": "likes",
        "page": f"{host}/authors/{author_id}/likes",
        "id": f"{host}/api/authors/{author_id}/likes",
        "page_number": page_number,
        "size": min(len(serialized_likes), size),
        "count": len(likes),
        "src": serialized_likes
    }
    return Response(likes_data)

@api_view(["GET"])
def get_like(request, like_id, author_id=None):
    '''
    API: returns a specific like
    '''
    if author_id:
        try:
            like = PostLike.objects.get(id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(id=like_id)
            post = False
    else:
        try:
            like = PostLike.objects.get(id=like_id)
            post = True
        except:
            like = CommentLike.objects.get(id=like_id)
            post = False
    if not like:
        return Response(status=404)
    if post:
        serializer = PostLikeSerializer(like)
    else:
        serializer = CommentLikeSerializer(like)
    return Response(serializer.data)

@api_view(["POST"])
def like_post(request, author_id, post_id):
    '''
    API: allows an author to like a post
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = post_id
        serializer = PostLikeSerializer(data=data)
        if serializer.is_valid():
            if PostLike.objects.filter(author=author_id, object=post_id).exists():
                PostLike.objects.filter(author=author_id, object=post_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
        
    like_count = PostLike.objects.filter(object=post_id).count()
    return Response({"like_count": like_count}, status=201)

@api_view(["POST"])
def like_comment(request, author_id, comment_id):
    '''
    API: allows an author to like a comment
    '''
    data = request.data.copy()
    if data.get("type") == "like":
        data["author"] = author_id
        data["object"] = comment_id
        serializer = CommentLikeSerializer(data=data)
        if serializer.is_valid():
            if CommentLike.objects.filter(author=author_id, object=comment_id).exists():
                CommentLike.objects.filter(author=author_id, object=comment_id).delete()
            else:
                try:
                    serializer.save()
                except Exception as e:
                    return Response(status=400, data={"error": str(e)})
        else:
            return Response(status=400, data={"error": serializer.errors})
    else:
        return Response(status=400, data={"error": "Invalid type."})
    
    like_count = CommentLike.objects.filter(object=comment_id).count()
    return Response({"like_count": like_count}, status=201)


@api_view(["GET", "PUT", "DELETE"])
@permission_classes([IsAuthenticated])
def modify_follower_api(request, author_id, foreign_author_encoded=None):
    """
    API endpoint to get, add, or remove a follower for the given author.
    
    GET:
      - If foreign_author_encoded is provided, check if that foreign author (after percent‐decoding)
        is a follower of the author with id=author_id. (If yes, return the author object; if not, 404.)
      - If not provided, return a list of all followers.
    
    PUT:
      - Add the foreign author (provided via percent encoded string) as a follower of the author.
        (Authenticated user must be the owner of the profile.)
    
    DELETE:
      - Remove the foreign author as a follower of the author.
        (Authenticated user must be the owner.)
    """
    import urllib.parse
    author = get_object_or_404(Author, id=author_id)
    if request.method == "GET":
        if foreign_author_encoded:
            foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
            try:
                foreign_author = Author.objects.get(id=foreign_author_id)
            except Author.DoesNotExist:
                return Response({"detail": "Foreign author not found."}, status=404)
            if author in foreign_author.following.all():
                return Response(AuthorSerializer(foreign_author).data, status=200)
            else:
                return Response({"detail": "Not a follower."}, status=404)
        else:
            followers = Author.objects.filter(following=author)
            data = {
                "type": "followers",
                "followers": AuthorSerializer(followers, many=True).data
            }
            return Response(data, status=200)
    elif request.method == "PUT":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(id=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        # To add the follower, we add the author to foreign_author.following.
        foreign_author.following.add(author)
        return Response({"detail": "Follower added."}, status=200)
    elif request.method == "DELETE":
        if not foreign_author_encoded:
            return Response({"detail": "Foreign author id required."}, status=400)
        foreign_author_id = urllib.parse.unquote(foreign_author_encoded)
        try:
            foreign_author = Author.objects.get(id=foreign_author_id)
        except Author.DoesNotExist:
            return Response({"detail": "Foreign author not found."}, status=404)
        if request.user.author != author:
            return Response({"detail": "Unauthorized."}, status=403)
        if author in foreign_author.following.all():
            foreign_author.following.remove(author)
            return Response({"detail": "Follower removed."}, status=200)
        else:
            return Response({"detail": "Foreign author is not a follower."}, status=404)


@api_view(["POST"])
def api_send_follow_request(request, author_id):
    """
    API: send a follow request to the author with id=author_id.
    The authenticated user is taken as the actor.
    Expects a JSON payload containing at least "type": "follow".
    """
    if not request.user.is_authenticated:
        return Response({"detail": "Authentication required."}, status=403)
    current_author = request.user.author
    target_author = get_object_or_404(Author, id=author_id)
    if current_author == target_author:
        return Response({"detail": "You cannot follow yourself."}, status=400)
    if FollowRequest.objects.filter(sender=current_author, receiver=target_author, status="PENDING").exists():
        return Response({"detail": "Follow request already sent."}, status=400)
    follow_req = FollowRequest.objects.create(sender=current_author, receiver=target_author)
    response_data = {
        "type": "follow",
        "summary": f"{current_author.display_name} wants to follow {target_author.display_name}",
        "actor": AuthorSerializer(current_author).data,
        "object": AuthorSerializer(target_author).data
    }
    return Response(response_data, status=201)
