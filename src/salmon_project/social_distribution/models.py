#Consulted OpenAI ChatGPT-4 on chat.openai.com using the chat function.
#Link: https://chat.openai.com/
#Executed on a MacBook Air M1 8 cores (4p4e) 8GB RAM.
#Code generated by the model is preceded by #<BEGIN GENERATED model="gpt-4" date=2025-02-18>
#and followed by #<END GENERATED></END>.

from django.db import models
import uuid
from django.conf import settings
from django.contrib.auth.models import User  
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.validators import FileExtensionValidator

class Author(models.Model):
    """
    An author who can create posts and comments and follow other authors
    """
    #<BEGIN GENERATED model="gpt-4" date=2025-02-18 prompt: here is my error (screenshot of error) why is this happening, i create an auther when i register, so why wont it redirect properly?>
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="author", null=True, blank=True)
    #<END GENERATED></END>
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    username = models.CharField(max_length=100, unique=True)
    fqid = models.URLField(unique=True, editable=False, null=True, blank=True)
    following = models.ManyToManyField('self', symmetrical=False, blank=True)
    display_name = models.CharField(max_length=100, default="Display Name")
    github = models.URLField(null=True, blank=True)
    profile_image = models.ImageField(upload_to="images/", null=True, blank=True)
    page = models.URLField(null=True, blank=True)
    host = models.URLField(default=settings.BASE_URL)
    is_approved = models.BooleanField(default=False)

    def __str__(self):
        return self.username
    
    def is_friends_with(self, other_author):
        return self in other_author.following.all() and other_author in self.following.all()
    
    def is_following(self, other_author):
        return self in other_author.following.all()
    
    def save(self, *args, **kwargs):
        if not self.fqid:
            self.fqid = f"{self.host.rstrip('/')}/authors/{self.id}"
        super().save(*args, **kwargs)

@receiver(post_save, sender=User)
def create_author_for_admin(sender, instance, created, **kwargs):
    if created and instance.is_superuser:  # Only create for superusers
        Author.objects.create(user=instance, username=instance.username, display_name=instance.get_full_name() or instance.username, is_approved=True)
        
class Post(models.Model):
    """
    A post by an author with text and/or an image
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    fqid = models.URLField(unique=True, editable=False, null=True, blank=True)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    text = models.TextField(null=True, blank=True)
    image = models.ImageField(upload_to="images/", null=True, blank=True)
    video = models.FileField(upload_to="videos/", null=True, blank=True,
                             validators=[FileExtensionValidator(allowed_extensions=["mp4", "mov", "avi"])])
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now_add=True)

    CONTENT_TYPE_CHOICES = [
        ("text/plain", "Plain Text"),
        ("text/markdown", "CommonMark"),
        ("image/png", "PNG Image"),
        ("image/jpeg", "JPEG Image"),
        ("video/mp4", "MP4 Video"),
    ]
    content_type = models.CharField(choices=CONTENT_TYPE_CHOICES, default="text/plain", max_length=100)
    
    # Visibility options for a post
    VISIBILITY_CHOICES = [
        ("PUBLIC", "Public"),
        ("UNLISTED", "Unlisted"),
        ("FRIENDS", "Friends"),
        ("DELETED", "Deleted"),
    ]
    visibility = models.CharField(choices=VISIBILITY_CHOICES, default="PUBLIC", max_length=100)
    
    def __str__(self):
        return f"Post by {self.author.username} at {self.created_at}"

    def save(self, *args, **kwargs):
        if not self.fqid:
            self.fqid = f"{self.author.host.rstrip('/')}/authors/{self.author.id}/posts/{self.id}"
        super().save(*args, **kwargs)

class PostLike(models.Model):
    """
    A like on a post by an author
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    object = models.ForeignKey(Post, on_delete=models.CASCADE)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    published = models.DateTimeField(auto_now_add=True)
    fqid = models.URLField(unique=True, editable=False, null=True, blank=True)

    # Ensure that a user can only like a post once
    # https://docs.djangoproject.com/en/5.1/ref/models/options/#unique-together
    class Meta:
        unique_together = ["object", "author"]

    def save(self, *args, **kwargs):
            if not self.fqid:
                self.fqid = f"{self.author.host.rstrip('/')}/api/authors/{self.author.id}/liked/{self.id}"
            super().save(*args, **kwargs)

class Comment(models.Model):
    """
    A comment on a post by an author
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    fqid = models.URLField(unique=True, editable=False, null=True, blank=True)
    post = models.ForeignKey(Post, on_delete=models.CASCADE)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    comment = models.TextField()

    COMMENT_CONTENT_TYPE_CHOICES = [
        ("text/plain", "Plain Text"),
        ("text/markdown", "CommonMark"),
    ]
    content_type = models.CharField(choices=COMMENT_CONTENT_TYPE_CHOICES, default="text/plain", max_length=100)
    published = models.DateTimeField(auto_now_add=True)
    
    def save(self, *args, **kwargs):
        if not self.fqid:
            self.fqid = f"{self.author.host.rstrip('/')}/api/authors/{self.author.id}/commented/{self.id}"
        super().save(*args, **kwargs)

class CommentLike(models.Model):
    """
    A like on a comment by an author
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    object = models.ForeignKey(Comment, on_delete=models.CASCADE)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    published = models.DateTimeField(auto_now_add=True)
    fqid = models.URLField(unique=True, editable=False, null=True, blank=True)

    # Ensure that a user can only like a comment once
    # https://docs.djangoproject.com/en/5.1/ref/models/options/#unique-together
    class Meta:
        unique_together = ["object", "author"]

    def save(self, *args, **kwargs):
        if not self.fqid:
            self.fqid = f"{self.author.host.rstrip('/')}/api/authors/{self.author.id}/liked/{self.id}"
        super().save(*args, **kwargs)


class FollowRequest(models.Model):
    STATUS_CHOICES = [
        ("PENDING", "Pending"),
        ("ACCEPTED", "Accepted"),
        ("DENIED", "Denied"),
    ]
    sender = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="sent_requests")  # The user who sends the follow request
    receiver = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="received_requests")  # The user receiving the request
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default="PENDING")  # NEW field for request status
    created_at = models.DateTimeField(auto_now_add=True)  # NEW field for when the request was sent

    def __str__(self):
        return f"{self.sender.username} -> {self.receiver.username} ({self.status})"
    

class FeedBlock(models.Model):
    blocker = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="feed_blocks")
    blocked_author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="blocked_by")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("blocker", "blocked_author")

    def __str__(self):
        return f"{self.blocker.username} blocks {self.blocked_author.username}"
    

class NodeInfo(models.Model):
    """
    Information about the local node
    """
    username = models.CharField(max_length=100)
    password = models.CharField(max_length=100)
    host = models.URLField(unique=True)

class RemoteNode(models.Model):
    """
    A node that can be connected to from our node
    """
    host = models.URLField(unique=True)
    outgoing = models.BooleanField()
    incoming = models.BooleanField()
